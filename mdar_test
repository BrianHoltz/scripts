#!/usr/bin/env bash
usageMsg="\
NAME
    mdar_test - Thorough and realistic testing for mdar

SYNOPSIS
    mdar_test [OPTIONS]

OPTIONS
    -h, --help            Show this usage message and exit
    -v                    Always show test output details, even if all tests pass
    -x                    Enable shell tracing for mdar_test itself
    -xx                   Enable shell tracing for mdar (pass -x to mdar)
    -l, --list-tests      List available tests and exit
    -t N, --test N        Run only test number N (see --list-tests)
    --ignore-tests LIST   Comma-separated list of test numbers to skip
    --setup-only          Create a realistic folder/file tree for experimentation and exit
    --keep-artifacts      Do not clean up test directories after running

DESCRIPTION
    Runs a suite of realistic tests for mdar, including move proposals, normalization,
    pruning, and sorting. By default, PASS/FAIL lines are shown for each test; use -v
    to always show test output details.
"

set -e

# Test counters must be global for test_case to increment them
passed=0
failed=0
current_test_num=0
test_descriptions=()


show_help() {
  echo "$usageMsg"
  exit 0
}

# Generate a realistic folder/file tree with empty files
setup_only() {
  local root="$1"
  mkdir -p "$root"
  mkdir -p "$root/Project Alpha/Docs"
  mkdir -p "$root/Project Alpha/Data"
  mkdir -p "$root/Project Beta/Images"
  mkdir -p "$root/Project Beta/Notes"
  mkdir -p "$root/Personal/Finances"
  mkdir -p "$root/Personal/Photos/2025"
  touch "$root/Project Alpha/README.md"
  touch "$root/Project Alpha/Docs/Spec v1.0.txt"
  touch "$root/Project Alpha/Data/data_01.csv"
  touch "$root/Project Beta/Images/logo-final (1).png"
  touch "$root/Project Beta/Notes/meeting notes (Nov 19).md"
  touch "$root/Personal/Finances/budget_2025.xlsx"
  touch "$root/Personal/Photos/2025/vacation photo 1.jpg"
  touch "$root/Personal/Photos/2025/vacation photo 2.jpg"
  touch "$root/Personal/Photos/2025/.DS_Store"
  touch "$root/emptyfile"
}

# Color helpers
color_pass() {
  if [ -t 1 ]; then
    printf '\033[1;92mPASS: %s\033[0m\n' "$1"
  else
    echo "PASS: $1"
  fi
}
color_fail() {
  if [ -t 1 ]; then
    printf '\033[1;91mFAIL: %s\033[0m\n' "$1"
  else
    echo "FAIL: $1"
  fi
}
header() {
  local text="$1"
  if [ -t 1 ]; then
    printf '\033[1m%s\033[0m\n' "$text"
  else
    echo "$text"
  fi
}

# Helper to clean up regex for display
clean_expect() {
  echo "$1" | sed 's/\[\[:space:\]\]*//g; s/\\(Nov 19\\)/\(Nov 19\)/g; s/\\[DELETE\\]/[DELETE]/g'
}

# Run a single test case
test_case() {
  local desc
  desc="$1"
  local cmd
  cmd="$2"
  shift 2
  local expect_lines=("$@")

  # Increment test number and record description
  ((current_test_num++))
  test_descriptions+=("Test $current_test_num: $desc")

  # Check if this test should be skipped
  if [ -n "$specificTest" ] && [ "$specificTest" != "$current_test_num" ]; then
    return 0  # Skip this test
  fi
  if [ -n "$ignoreTests" ]; then
    IFS=',' read -ra IGNORE_ARRAY <<< "$ignoreTests"
    for skip_num in "${IGNORE_ARRAY[@]}"; do
      if [ "$skip_num" = "$current_test_num" ]; then
        return 0  # Skip this test
      fi
    done
  fi

  local LAST_OUTFILE
  LAST_OUTFILE=$(mktemp /tmp/mdar_test_out.XXXXXX)
  eval "$cmd" >"$LAST_OUTFILE" 2>&1 || true
  local result=0
  local output
  output=$(cat "$LAST_OUTFILE" | perl -pe 's/\e\[[\d;]*[A-Za-z]//g') # strip color codes

  for expect in "${expect_lines[@]}"; do
    if ! echo "$output" | grep -E -q "$expect"; then
      result=1
      break
    fi
  done

  # Show details in verbose mode or on failure
  if [[ $verboseTest -eq 1 || $result -ne 0 ]]; then
    printf '\033[1m### Test: %s\033[0m\n' "$desc"
    echo '```'
    cat "$LAST_OUTFILE"
    echo '```'
    echo "  Command: $cmd"
    for b in "${expect_lines[@]}"; do
      [[ -n "$b" ]] && echo "  - Expect: $(clean_expect "$b")"
    done
    if [[ $result -ne 0 ]]; then
      echo "  Output:"
      cat "$LAST_OUTFILE" | head -50
    fi
    if [[ $result -eq 0 ]]; then
      color_pass "$desc"
      ((passed++))
    else
      color_fail "$desc"
      ((failed++))
    fi
  else
    if [[ $result -eq 0 ]]; then
      color_pass "$desc"
      ((passed++))
    else
      color_fail "$desc"
      ((failed++))
    fi
  fi

  rm -f "$LAST_OUTFILE" # Temp file is deleted after each test
  return $result
}

# Strict output order check for sorting test
strict_sort_test_case() {
  local desc
  desc="$1"
  local cmd
  cmd="$2"
  shift 2
  local expect_patterns=("$@")

  # Increment test number and record description
  ((current_test_num++))
  test_descriptions+=("Test $current_test_num: $desc")

  # Check if this test should be skipped
  if [ -n "$specificTest" ] && [ "$specificTest" != "$current_test_num" ]; then
    return 0  # Skip this test
  fi
  if [ -n "$ignoreTests" ]; then
    IFS=',' read -ra IGNORE_ARRAY <<< "$ignoreTests"
    for skip_num in "${IGNORE_ARRAY[@]}"; do
      if [ "$skip_num" = "$current_test_num" ]; then
        return 0  # Skip this test
      fi
    done
  fi

  local LAST_OUTFILE
  LAST_OUTFILE=$(mktemp /tmp/mdar_test_out.XXXXXX)
  eval "$cmd" >"$LAST_OUTFILE" 2>&1 || true
  local result=0
  local output
  output=$(cat "$LAST_OUTFILE" | perl -pe 's/\e\[[\d;]*[A-Za-z]//g')

  # Extract only lines with '→' and not '[DELETE]'
  local actual_lines=()
  local actual_targets=()
  while IFS= read -r line; do
    if [[ $line =~ → && ! $line =~ \[DELETE\] ]]; then
      actual_lines+=("$line")
      # Extract right-hand side (target name)
      target=$(echo "$line" | awk -F '→' '{print $2}' | sed 's/^ *//')
      actual_targets+=("$target")
    fi
  done <<< "$output"

  # Check if actual_targets is sorted lexicographically
  local sorted_targets=()
  while IFS= read -r line; do
    [ -n "$line" ] && sorted_targets+=("$line")
  done < <(printf '%s\n' "${actual_targets[@]}" | sort)
  local is_sorted=1
  for ((i=0;i<${#actual_targets[@]};i++)); do
    if [[ "${actual_targets[$i]}" != "${sorted_targets[$i]}" ]]; then
      is_sorted=0
      break
    fi
  done
  if [[ $is_sorted -eq 0 ]]; then
    result=1
    echo "  Target names are not sorted by full path!"
    echo "  Actual order:"
    for t in "${actual_targets[@]}"; do echo "    $t"; done
    echo "  Expected sorted order:"
    for t in "${sorted_targets[@]}"; do echo "    $t"; done
  fi

  # Extract only patterns with '→' and not '[DELETE]'
  local expected_patterns=()
  for e in "${expect_patterns[@]}"; do
    if [[ $e =~ → && ! $e =~ \[DELETE\] ]]; then
      expected_patterns+=("$e")
    fi
  done

  # Check that we have the same number of lines
  if [[ ${#actual_lines[@]} -ne ${#expected_patterns[@]} ]]; then
    result=1
  else
    # Check each line matches expected pattern in order
    for ((i=0;i<${#expected_patterns[@]};i++)); do
      if ! echo "${actual_lines[$i]}" | grep -E -q "${expected_patterns[$i]}"; then
        result=1
        break
      fi
    done
  fi

  # Show details in verbose mode or on failure
  if [[ $verboseTest -eq 1 || $result -ne 0 ]]; then
    printf '\033[1m### Test: %s\033[0m\n' "$desc"
    echo '```'
    cat "$LAST_OUTFILE"
    echo '```'
    echo "  Command: $cmd"
    for b in "${expect_patterns[@]}"; do
      [[ -n "$b" ]] && echo "  - Expect: $(clean_expect "$b")"
    done
    if [[ $result -ne 0 ]]; then
      echo "  Output order mismatch or count mismatch!"
      echo "  Expected ${#expected_patterns[@]} matches in order:"
      for p in "${expected_patterns[@]}"; do echo "    $(clean_expect "$p")"; done
      echo "  Actual ${#actual_lines[@]} lines:"
      for l in "${actual_lines[@]}"; do echo "    $l"; done
    fi
    if [[ $result -eq 0 ]]; then
      color_pass "$desc"
      ((passed++))
    else
      color_fail "$desc"
      ((failed++))
    fi
  else
    if [[ $result -eq 0 ]]; then
      color_pass "$desc"
      ((passed++))
    else
      color_fail "$desc"
      ((failed++))
    fi
  fi

  rm -f "$LAST_OUTFILE" # Temp file is deleted after each test
  return $result
}

# Global test directory for all test cases
# Must be set before run_tests so all test_case invocations use the correct path
TESTDIR=""

extract_usageMsg() {
  "$HOME/bin/mdar" -H
}

list_tests() {
  echo "Available tests:"
  echo "  1: mdar usageMsg matches --help output"
  echo "  2: mdar proposes move for untracked .md file"
  echo "  3: mdar suggests normalization for test-results files"
  echo "  4: mdar marks old aidocs files for pruning"
  echo "  5: mdar prunes old files in test-results/"
  echo "  6: mdar sorts recommended target names (by mtime and name)"
  exit 0
}

run_tests() {
  set +e  # Disable exit-on-error so all tests run
  TESTDIR=$(mktemp -d)
  [ "$verboseTest" -eq 1 ] && echo "Created TESTDIR: $TESTDIR"
  local testdir="$TESTDIR"

  # Set mdar_cmd for use in test commands
  if [[ $mdarTrace -eq 1 ]]; then
    mdar_cmd="$HOME/bin/mdar -x"
  else
    mdar_cmd="$HOME/bin/mdar"
  fi

  echo ""

  # Test 1: Usage message consistency
  test_case "mdar usageMsg matches --help output" \
    "extract_usageMsg > $testdir/usage_raw && $HOME/bin/mdar --help | perl -pe 's/\\e\\[[\\d;]*[A-Za-z]//g' > $testdir/usage_help && diff -u $testdir/usage_raw $testdir/usage_help" \
    ""

  # Test 2: Basic archival
  local t2="$testdir/test2"
  mkdir -p "$t2"
  setup_only "$t2"
  echo "# Project notes" > "$t2/Project Alpha/PROJECT_NOTES.md"
  touch -t 201801010101 "$t2/Project Alpha/PROJECT_NOTES.md"
  touch -t 201902020202 "$t2/Project Beta/Notes/meeting notes (Nov 19).md"
  touch -t 202003030303 "$t2/Project Alpha/Docs/Spec v1.0.txt"
  mkdir -p "$t2/testdir"
  echo "# Test MD file" > "$t2/testdir/testfile.md"
  touch -t 202404040404 "$t2/testdir/testfile.md"

  test_case "mdar proposes move for untracked .md file" \
    "cd $t2 && $mdar_cmd -n --prune 2000d --depth 3 --yes" \
    "Project Alpha/PROJECT_NOTES.md.*→.*aidocs/2018-01-01/0101_ProjectNotes.md" \
    "Project Beta/Notes/meeting notes \\(Nov 19\\).md.*→.*aidocs/2019-02-02/0202_Meeting notes \\(Nov 19\\).md" \
    "testdir/testfile.md.*→.*aidocs/2024-04-04/0404_Testfile.md" \
    "Dry-run: Executed 0 of 3 proposed operations"

  # Test 3: Normalization with alternate archive
  local t3="$testdir/test3"
  mkdir -p "$t3/test-results"
  echo "Sample" > "$t3/test-results/summary 2025.txt"
  touch -t 202212121212 "$t3/test-results/summary 2025.txt"
  echo "Old test result" > "$t3/test-results/old_result.txt"
  touch -t 201701010000 "$t3/test-results/old_result.txt"

  test_case "mdar suggests normalization for test-results files" \
    "cd $t3 && $mdar_cmd -n --normalize test-results --depth 3 --yes" \
    "test-results/summary 2025.txt.*→.*test-results/2022-12-12_1212_Summary 2025.txt" \
    "test-results/old_result.txt.*→.*test-results/2017-01-01_0000_OldResult.txt" \
    "Dry-run: Executed 0 of 2 proposed operations"

  # Test 4: Pruning old aidocs
  local t4="$testdir/test4"
  mkdir -p "$t4/aidocs/2019-01-01"
  echo "Old content" > "$t4/aidocs/2019-01-01/0000_Old.md"
  touch -t 201701010000 "$t4/aidocs/2019-01-01/0000_Old.md"
  mkdir -p "$t4/test-results"
  echo "Sample" > "$t4/test-results/summary 2025.txt"
  touch -t 202212121212 "$t4/test-results/summary 2025.txt"

  test_case "mdar marks old aidocs files for pruning" \
    "cd $t4 && $mdar_cmd -n --normalize test-results --prune 2000d --depth 3 --yes" \
    "aidocs/2019-01-01/0000_Old.md.*→.*\\[DELETE\\]" \
    "Dry-run: Executed 0 of 2 proposed operations"

  # Test 5: Pruning in test-results (without normalize flag, so pruning takes precedence)
  local t5="$testdir/test5"
  mkdir -p "$t5/test-results"
  echo "Old test result" > "$t5/test-results/old_result.txt"
  touch -t 201701010000 "$t5/test-results/old_result.txt"

  test_case "mdar prunes old files in test-results/" \
    "cd $t5 && $mdar_cmd -n --prune 2000d --depth 3 --yes" \
    "test-results/old_result.txt.*→.*\\[DELETE\\]" \
    "Dry-run: Executed 0 of 1 proposed operations"

  # Test 6: Sorting test
  local t6="$testdir/test6"
  mkdir -p "$t6/testdir"
  echo "Zeta" > "$t6/testdir/zeta_notes.md"
  touch -t 202301150900 "$t6/testdir/zeta_notes.md"
  echo "Alpha" > "$t6/testdir/alpha_notes.md"
  touch -t 202403221430 "$t6/testdir/alpha_notes.md"
  echo "Beta" > "$t6/testdir/beta_notes.md"
  touch -t 202403221445 "$t6/testdir/beta_notes.md"
  echo "Delta" > "$t6/testdir/delta_notes.md"
  touch -t 202506180830 "$t6/testdir/delta_notes.md"
  echo "Gamma" > "$t6/testdir/gamma_notes.md"
  touch -t 202510011200 "$t6/testdir/gamma_notes.md"

  strict_sort_test_case "mdar sorts recommended target names (by mtime and name)" \
    "cd $t6 && $mdar_cmd -n --depth 2 --yes" \
    "testdir/zeta_notes.md.*→.*aidocs/2023-01-15/0900_ZetaNotes.md" \
    "testdir/alpha_notes.md.*→.*aidocs/2024-03-22/1430_AlphaNotes.md" \
    "testdir/beta_notes.md.*→.*aidocs/2024-03-22/1445_BetaNotes.md" \
    "testdir/delta_notes.md.*→.*aidocs/2025-06-18/0830_DeltaNotes.md" \
    "testdir/gamma_notes.md.*→.*aidocs/2025-10-01/1200_GammaNotes.md" \
    "Dry-run: Executed 0 of 5 proposed operations"

  echo ""
  header "### Test Summary"
  total_tests=$((passed+failed))
  if [ -t 1 ]; then
    color_reset='\033[0m'
    color_green='\033[1;32m'
    color_red='\033[1;31m'
    summary_colored="Results: Tests run: $total_tests, "
    if [[ $failed -gt 0 ]]; then
      summary_colored+="${color_red}Failures${color_reset}: ${color_red}$failed${color_reset}"
    else
      summary_colored+="Failures: $failed"
    fi
    summary_colored+=", "
    if [[ $passed -gt 0 ]]; then
      summary_colored+="${color_green}Successes${color_reset}: ${color_green}$passed${color_reset}"
    else
      summary_colored+="Successes: $passed"
    fi
    printf '%b\n' "$summary_colored"
  else
    echo "Results: Tests run: $total_tests, Failures: $failed, Successes: $passed"
  fi

  if [[ "$KEEP_ARTIFACTS" != "1" ]]; then
    rm -rf "$testdir"
  else
    echo "Test artifacts kept at $testdir"
  fi

  if [[ $failed -gt 0 ]]; then
    return 1
  fi
  return 0
}



# Parse arguments
setupOnly=0
keepArtifacts=0
shellTrace=0
mdarTrace=0
verboseTest=0
listTests=0
specificTest=""
ignoreTests=""

while [[ $# -gt 0 ]]; do
  case "$1" in
    --setup-only)
      setupOnly=1 ;;
    --keep-artifacts)
      keepArtifacts=1 ;;
    -x)
      shellTrace=1 ;;
    -xx)
      mdarTrace=1 ;;
    -v)
      verboseTest=1 ;;
    -l|--list-tests)
      listTests=1 ;;
    -t|--test)
      specificTest="$2"
      shift ;;
    --ignore-tests)
      ignoreTests="$2"
      shift ;;
    -h|--help)
      show_help ;;
    --)
      shift
      break ;;
    -*|*)
      echo "Unknown option: $1"
      echo "Use -h or --help for usage information."
      exit 1
      ;;
  esac
  shift
done

# Export KEEP_ARTIFACTS so run_tests can read it (it checks this env var)
if [[ $keepArtifacts -eq 1 ]]; then
  export KEEP_ARTIFACTS=1
fi

if [[ $shellTrace -eq 1 ]]; then
  set -x
fi

if [[ $listTests -eq 1 ]]; then
  list_tests
fi

if [[ $setupOnly -eq 1 ]]; then
  setup_only "./mdar_test_tree"
  echo "Created test tree at ./mdar_test_tree"
  exit 0
fi

# Now run the main test suite. run_tests creates TESTDIR and executes tests.
run_tests
exit $?
