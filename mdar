#!/bin/bash
usageMsg="\
NAME
    mdar - Archive untracked markdown files as aidocs/YYYY-MM-DD/hhmm_CamelCase.md

SYNOPSIS
    mdar [--archive DIR] [--no-timestamp] [--no-camelcase] [-y|--yes]
         [-r|--recursive] [--depth N] [--normalize DIR] [--prune N<mhdwMy>]
         [-v|-vv|-vvv] [-x] [-n|--dry-run]

DESCRIPTION
    Archive untracked markdown files into dated folders, by default normalized to
    aidocs/YYYY-MM-DD/hhmm_CamelCasedVersionOfOriginalName.md.
    This cleans up AI-generated docs, sorting them in IDE folder viewers.

OPTIONS
    --archive DIR       Archive directory (default: aidocs/)
    --no-timestamp      Do not normalize filenames with hhmm create-time prefix
    --no-camelcase      Do not normalize filenames to CamelCase
    -n, --dry-run       Show proposed mv operations and exit (no prompt, no changes)
    -y, --yes           Skip confirmation prompt, execute mv operations immediately
    -v, -vv, -vvv       Loglevel 1=counts 2=+find/git/mv 3=+pipelines
    -x                  Enable shell tracing (set -x)
    -r, --recursive     Search all subdirectories recursively (depth=∞)
    --depth N           Directory depth to search (0=root only, default: 2)
    --normalize DIR     Normalize DIR in-place (default: test-results/, can be repeated)
    --prune N<mhdwMy>   Delete target files older than e.g., 30d, 4w, 1M
"

# usageMsg is intentionally placed at the very top for human readers and future agents.
# It must start on the second line of the script, right below the shebang.
# usageMsg formatting and content ALWAYS trumps showUsage. If you change usageMsg,
# you MUST update showUsage to match it EXACTLY, including newlines and spacing.
# Agents must not update usageMsg without explicit instructions to do so.
# When they aren't in sync, agents must update showUsage's underlying
# non-colorized text to match usageMsg, while keeping all colorization intact.

set -e # Exit on error

main() {
    local autoConfirm=0
    local depth=2
    local verbose=0
    local dryRun=0
    local normalizeDirs=()
    local pruneDuration=""
    local repoRoot
    local inGitRepo=0
    local archiveDir="aidocs"
    local noTimestamp=0
    local noCamelCase=0

    # Print to terminal a colorized version of the usage message.
    # IMPORTANT: usageMsg formatting ALWAYS trumps showUsage. If you change usageMsg, you MUST update showUsage to match it EXACTLY, including newlines and spacing. Do NOT change showUsage formatting independently.
    showUsage() {
        local RESET=$'\033[0m'
        local BOLD=$'\033[1m'
        local UNDERLINE=$'\033[4m'
        local ITALIC=$'\033[3m'
        # Color codes (24-bit RGB)
        local CMD_COLOR=$'\033[38;2;30;144;255m'           # Command: DodgerBlue
        local FLAG_COLOR=$'\033[38;2;0;191;255m'           # Flag: DeepSkyBlue
        local FS_VAR_COLOR=$'\033[38;2;60;179;113m'        # Filesystem Variable: MediumSeaGreen
        local FS_LIT_COLOR=$'\033[38;2;0;255;0m'           # Filesystem Literal: Lime
        local ARG_VAR_COLOR=$'\033[38;2;255;165;0m'        # Argument Variable: Orange
        local ARG_LIT_COLOR=$'\033[38;2;255;140;0m'        # Argument Literal: DarkOrange

        # NAME
        echo -e "${BOLD}${UNDERLINE}NAME${RESET}"
        echo -e "    ${CMD_COLOR}mdar${RESET} - Archive untracked markdown files as ${FS_LIT_COLOR}aidocs/${RESET}${FS_VAR_COLOR}${UNDERLINE}YYYY-MM-DD/hhmm_CamelCase${RESET}${FS_LIT_COLOR}.md${RESET}"
        echo
        # SYNOPSIS
        echo -e "${BOLD}${UNDERLINE}SYNOPSIS${RESET}"
        echo -e "    ${CMD_COLOR}mdar${RESET} [${FLAG_COLOR}--archive${RESET} ${FS_VAR_COLOR}${ITALIC}${UNDERLINE}DIR${RESET}] [${FLAG_COLOR}--no-timestamp${RESET}] [${FLAG_COLOR}--no-camelcase${RESET}] [${FLAG_COLOR}-y${RESET}|${FLAG_COLOR}--yes${RESET}]"
        echo -e "         [${FLAG_COLOR}-r${RESET}|${FLAG_COLOR}--recursive${RESET}] [${FLAG_COLOR}--depth${RESET} ${ARG_VAR_COLOR}${ITALIC}N${RESET}] [${FLAG_COLOR}--normalize${RESET} ${FS_VAR_COLOR}${ITALIC}${UNDERLINE}DIR${RESET}] [${FLAG_COLOR}--prune${RESET} ${ARG_VAR_COLOR}${ITALIC}N<mhdwMy>${RESET}]"
        echo -e "         [${FLAG_COLOR}-v${RESET}|${FLAG_COLOR}-vv${RESET}|${FLAG_COLOR}-vvv${RESET}] [${FLAG_COLOR}-x${RESET}] [${FLAG_COLOR}-n${RESET}|${FLAG_COLOR}--dry-run${RESET}]"
        echo
        # DESCRIPTION
        echo -e "${BOLD}${UNDERLINE}DESCRIPTION${RESET}"
        echo -e "    Archive untracked markdown files into dated folders, by default normalized to"
        echo -e "    ${FS_LIT_COLOR}aidocs/${RESET}${FS_VAR_COLOR}${UNDERLINE}YYYY-MM-DD/hhmm_CamelCasedVersionOfOriginalName${RESET}${FS_LIT_COLOR}.md${RESET}."
        echo -e "    This cleans up AI-generated docs, sorting them in IDE folder viewers."
        echo
        # OPTIONS
        echo -e "${BOLD}${UNDERLINE}OPTIONS${RESET}"
        echo -e "    ${FLAG_COLOR}--archive${RESET} ${FS_VAR_COLOR}${ITALIC}${UNDERLINE}DIR${RESET}       Archive directory (default: ${FS_LIT_COLOR}${UNDERLINE}aidocs/${RESET})"
        echo -e "    ${FLAG_COLOR}--no-timestamp${RESET}      Do not normalize filenames with ${ARG_VAR_COLOR}${ITALIC}hhmm${RESET} create-time prefix"
        echo -e "    ${FLAG_COLOR}--no-camelcase${RESET}      Do not normalize filenames to ${FS_VAR_COLOR}${ITALIC}${UNDERLINE}CamelCase${RESET}"
        echo -e "    ${FLAG_COLOR}-n${RESET}, ${FLAG_COLOR}--dry-run${RESET}       Show proposed ${CMD_COLOR}${BOLD}mv${RESET} operations and exit (no prompt, no changes)"
        local YES_COLOR=$'\033[38;2;239;83;80m' # Bright Red
        echo -e "    ${YES_COLOR}-y${RESET}, ${YES_COLOR}--yes${RESET}           ${YES_COLOR}${BOLD}Skip confirmation prompt, execute${RESET} ${YES_COLOR}${BOLD}mv${RESET} ${YES_COLOR}${BOLD}operations immediately${RESET}"
        echo -e "    ${FLAG_COLOR}-v${RESET}, ${FLAG_COLOR}-vv${RESET}, ${FLAG_COLOR}-vvv${RESET}       Verbosity: ${FLAG_COLOR}-v${RESET}=${CMD_COLOR}find${RESET}/${CMD_COLOR}mv${RESET} files, ${FLAG_COLOR}-vv${RESET}=+debug, ${FLAG_COLOR}-vvv${RESET}=+shell tracing"
        echo -e "    ${FLAG_COLOR}-x${RESET}                  Enable shell tracing (${CMD_COLOR}${BOLD}set -x${RESET})"
        echo -e "    ${FLAG_COLOR}-r${RESET}, ${FLAG_COLOR}--recursive${RESET}     Search all subdirectories recursively (depth=${ARG_VAR_COLOR}${ITALIC}∞${RESET})"
        echo -e "    ${FLAG_COLOR}--depth${RESET} ${ARG_VAR_COLOR}${ITALIC}N${RESET}           Directory depth to search (${ARG_LIT_COLOR}0${RESET}=root only, default: ${ARG_LIT_COLOR}2${RESET})"
        echo -e "    ${FLAG_COLOR}--normalize${RESET} ${FS_VAR_COLOR}${ITALIC}${UNDERLINE}DIR${RESET}     Normalize ${FS_VAR_COLOR}${ITALIC}${UNDERLINE}DIR${RESET} in-place (default: ${FS_LIT_COLOR}${UNDERLINE}test-results/${RESET}, can be repeated)"
        echo -e "    ${FLAG_COLOR}--prune${RESET} ${ARG_VAR_COLOR}${ITALIC}N<mhdwMy>${RESET}   Delete target files older than e.g., ${ARG_LIT_COLOR}30d${RESET}, ${ARG_LIT_COLOR}4w${RESET}, ${ARG_LIT_COLOR}1M${RESET}"
    }

    # vlog: logging utility (define before any calls so it's available during option parsing and early runtime checks)
    # Log levels:
    # 1: Basic discovery/context, non-fatal errors (e.g., git repo status, counts of markdowns)
    # 2: Important subcommands (describe git/find/mv commands and why they're run)
    # 3: All interesting shell pipelines and transformations (full trace)
    vlog() {
        local level="$1"; shift
        if [ "$verbose" -ge "$level" ]; then
            echo "+ $*" >&2
        fi
    }

    # Manual option parsing for macOS compatibility (BSD getopt doesn't support long options)
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --archive)
                archiveDir="$2"; shift 2 ;;
            --no-timestamp)
                noTimestamp=1; shift ;;
            --no-camelcase)
                noCamelCase=1; shift ;;
            -n|--dry-run)
                dryRun=1; shift ;;
            -y|--yes)
                autoConfirm=1; shift ;;
            -r|--recursive)
                depth=-1; shift ;;
            --depth)
                depth="$2"; shift 2 ;;
            --normalize)
                normalizeDirs+=("$2"); shift 2 ;;
            --prune)
                pruneDuration="$2"; shift 2 ;;
            -v)
                verbose=$((verbose+1)); shift ;;
            -vv)
                verbose=$((verbose+2)); shift ;;
            -vvv)
                verbose=$((verbose+3)); shift ;;
            -vvvv)
                verbose=$((verbose+4)); shift ;;
            --verbose)
                verbose=$((verbose+1)); shift ;;
            -x)
                set -x; shift ;;
            -h|--help)
                showUsage; exit 0 ;;
            -H|--raw-help)
                printf "%s" "$usageMsg"; exit 0 ;;
            --)
                shift; break ;;
            -*)
                echo "Unknown option: $1" >&2
                showUsage >&2
                exit 1 ;;
            *)
                break ;;
        esac
    done

    vlog 2 "To find out if we are in a git repo, running: git rev-parse --git-dir"
    if git rev-parse --git-dir > /dev/null 2>&1; then
        inGitRepo=1
        repoRoot=$(git rev-parse --show-toplevel)
    else
        repoRoot=$(pwd)
    fi
    cd "$repoRoot"


    normalizePaths() {
        vlog 4 "normalizePaths: Strip leading './' and drop empty lines"
        local in="$1"
        echo "$in" | sed -e 's|^\./||' -e 's|^$||' | grep -v '^$' || true
    }

    findUntrackedMarkdown() {
        vlog 3 "findUntrackedMarkdown: repoRoot=$1, depth=$2, inGitRepo=$3"
        local repoRoot="$1"
        local depth="$2"
        local inGitRepo="$3"
        local files=""
        if [ "$inGitRepo" -eq 1 ]; then
            vlog 1 "In git repo: $repoRoot"
            vlog 2 "To find untracked markdown, running: git status --porcelain, git ls-files"
            statusFiles=$(git --no-pager -C "$repoRoot" status --porcelain | grep '^?? ' | sed 's/^?? //' || true)
            lsFiles=$(git --no-pager -C "$repoRoot" ls-files --others --exclude-standard || true)
            vlog 3 "Combining statusFiles and lsFiles, sorting, deduping, filtering for .md files"
            # Combine both sources, sort/dedupe, remove blank lines, keep only .md files, exclude aidocs/
            files=$(printf "%s\n%s\n" "$statusFiles" "$lsFiles" | sort | uniq | grep -v '^$' | grep '\.md$' | grep -v '^aidocs/')
            if [ "$depth" -ge 0 ]; then
                vlog 3 "Filtering markdown files by depth: $depth"
                files=$(echo "$files" | awk -F'/' -v depth="$depth" 'NF <= depth + 1')
            fi
        else
            vlog 1 "Not in a git repo. Searching for markdown files in: $repoRoot"
            if [ "$depth" -eq -1 ]; then
                vlog 2 "Running: find . -type f -name '*.md' (recursive)"
                # Find all markdown files, strip leading './', exclude aidocs/
                files=$(cd "$repoRoot" && find . -type f -name '*.md' 2>/dev/null | sed 's|^./||' | grep -v '^aidocs/')
            else
                vlog 2 "Running: find . -maxdepth $((depth + 1)) -type f -name '*.md'"
                # Find markdown files up to maxdepth, strip leading './', exclude aidocs/
                files=$(cd "$repoRoot" && find . -maxdepth $((depth + 1)) -type f -name '*.md' 2>/dev/null | sed 's|^./||' | grep -v '^aidocs/')
            fi
        fi
        echo "$files"
    }

    extractTimestamp() {
        vlog 4 "extractTimestamp: Extract timestamp from filename: $1"
        local filename="$1"
        local date="" time=""
        # BASH_REMATCH is a bash array containing the full match and capture groups from the last successful regex match in [[ ... =~ ... ]].
        # BASH_REMATCH[0] is the full match, BASH_REMATCH[1] is the first capture group, BASH_REMATCH[2] is the second, etc.
        # Regex: Matches YYYY-MM-DD_hhmmSS or YYYY-MM-DD_hhmm
        if [[ "$filename" =~ ([0-9]{4}-[0-9]{2}-[0-9]{2})_([0-9]{6}) ]]; then
            date="${BASH_REMATCH[1]}"; time="${BASH_REMATCH[2]:0:4}"
        # Regex: Matches YYYY-MM-DD_hhmm
        elif [[ "$filename" =~ ([0-9]{4}-[0-9]{2}-[0-9]{2})_([0-9]{4}) ]]; then
            date="${BASH_REMATCH[1]}"; time="${BASH_REMATCH[2]}"
        # Regex: Matches YYYYMMDD_hhmmSS
        elif [[ "$filename" =~ ([0-9]{8})_([0-9]{6}) ]]; then
            date="${BASH_REMATCH[1]:0:4}-${BASH_REMATCH[1]:4:2}-${BASH_REMATCH[1]:6:2}"; time="${BASH_REMATCH[2]:0:4}"
        # Regex: Matches YYYYMMDD_hhmm
        elif [[ "$filename" =~ ([0-9]{8})_([0-9]{4}) ]]; then
            date="${BASH_REMATCH[1]:0:4}-${BASH_REMATCH[1]:4:2}-${BASH_REMATCH[1]:6:2}"; time="${BASH_REMATCH[2]}"
        # Regex: Matches YYYYMMDD-hhmmSS
        elif [[ "$filename" =~ ([0-9]{4})([0-9]{2})([0-9]{2})-([0-9]{2})([0-9]{2})([0-9]{2}) ]]; then
            date="${BASH_REMATCH[1]}-${BASH_REMATCH[2]}-${BASH_REMATCH[3]}"; time="${BASH_REMATCH[4]}${BASH_REMATCH[5]}"
        # Regex: Matches YYYYMMDDhhmmSS
        elif [[ "$filename" =~ ([0-9]{4})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2}) ]]; then
            date="${BASH_REMATCH[1]}-${BASH_REMATCH[2]}-${BASH_REMATCH[3]}"; time="${BASH_REMATCH[4]}${BASH_REMATCH[5]}"
        # Regex: Matches YYYY-MM-DD-hhmmSS
        elif [[ "$filename" =~ ([0-9]{4})-([0-9]{2})-([0-9]{2})-([0-9]{2})([0-9]{2})([0-9]{2}) ]]; then
            date="${BASH_REMATCH[1]}-${BASH_REMATCH[2]}-${BASH_REMATCH[3]}"; time="${BASH_REMATCH[4]}${BASH_REMATCH[5]}"
        # Regex: Matches YYYY-MM-DD
        elif [[ "$filename" =~ ([0-9]{4})-([0-9]{2})-([0-9]{2}) ]]; then
            date="${BASH_REMATCH[1]}-${BASH_REMATCH[2]}-${BASH_REMATCH[3]}"; time="0000"
        # Regex: Matches YYYYMMDD
        elif [[ "$filename" =~ ([0-9]{4})([0-9]{2})([0-9]{2}) ]]; then
            date="${BASH_REMATCH[1]}-${BASH_REMATCH[2]}-${BASH_REMATCH[3]}"; time="0000"
        fi
        echo "$date|$time"
    }

    toCamelCase() {
        vlog 4 "toCamelCase: Convert filename to CamelCase, stripping timestamps: $1"
        local filename="$1"
        local base="${filename%.*}"
        # Remove common timestamp patterns so numeric timestamps don't become words in the
        # CamelCase result. This handles several formats (YYYY-MM-DD, YYYYMMDD, compact
        # datetime strings with or without separators) before we split on '_' or '-'.
        # Strip YYYY-MM-DD[_hhmm...] style timestamps
        base=$(echo "$base" | sed -E 's/[_-]?[0-9]{4}-[0-9]{2}-[0-9]{2}(_[0-9]{4,6})?[_-]?//g')
        # Strip YYYYMMDD-hhmmss style timestamps
        base=$(echo "$base" | sed -E 's/[_-]?[0-9]{8}-[0-9]{6}[_-]?//g')
        # Strip compact YYYYMMDDhhmmss timestamps
        base=$(echo "$base" | sed -E 's/[_-]?[0-9]{14}[_-]?//g')
        # Strip compact YYYYMMDD timestamps
        base=$(echo "$base" | sed -E 's/[_-]?[0-9]{8}[_-]?//g')
        if [[ ! "$base" =~ [_-] ]]; then
            if [[ "$base" =~ ^[A-Z0-9]+$ ]]; then
                # Token is ALL CAPS/alphanumeric (likely an acronym or constant).
                # Convert to Title case (first letter uppercase, rest lowercase) so
                # acronyms become readable names (e.g. FOO -> Foo) instead of ALLCAPS.
                echo "$(echo "$base" | awk '{print toupper(substr($0,1,1)) tolower(substr($0,2))}')"
            else
                # Mixed case or lowercase token: preserve the original casing except
                # ensure the first character is uppercase for consistency (e.g. myFile -> MyFile).
                echo "$(echo "${base:0:1}" | tr '[:lower:]' '[:upper:]')${base:1}"
            fi
            return
        fi
        # Multiple parts separated by '_' or '-': replace separators with spaces,
        # Title-case each word, then remove spaces to produce CamelCase (MyFileName).
        # Split on separators, titlecase words with awk, then join
        echo "$base" | sed -e 's/[_-]/ /g' | awk '{for(i=1;i<=NF;i++){$i=toupper(substr($i,1,1)) tolower(substr($i,2))}}1' | sed 's/ //g'
    }

    # Parse duration string to seconds
    parseDurationToSeconds() {
        local duration="$1"
        local num="${duration%[mhdwMy]}"
        local unit="${duration#$num}"
        [ -z "$unit" ] && unit="d"
        case "$unit" in
            m) echo $((num * 60)) ;;
            h) echo $((num * 3600)) ;;
            d) echo $((num * 86400)) ;;
            w) echo $((num * 7 * 86400)) ;;
            M) echo $((num * 30 * 86400)) ;;
            y) echo $((num * 365 * 86400)) ;;
            *) echo "Invalid duration unit: $unit" >&2; return 1 ;;
        esac
    }

    collectPruneOps() {
        vlog 3 "collectPruneOps: find files in $archiveDir older than cutoff time $cutoffTime"
        local repoRoot="$1" duration="$2" archiveDir="$3"
        local cutoffTime
        cutoffTime=$(($(date +%s) - $(parseDurationToSeconds "$duration")))
        local pruneOps=()
        # Use NUL-delimited find to handle filenames with spaces/newlines and
        # exclude the archive root README.md explicitly.
        while IFS= read -r -d '' f; do
            # Make path relative (strip leading ./ if present)
            f="${f#./}"
            [ "$f" = "${archiveDir}/README.md" ] && continue
            local mtime
            mtime=$(stat -f "%m" "$repoRoot/$f" 2>/dev/null || echo 0)
            [ "$mtime" -lt "$cutoffTime" ] && pruneOps+=("$f")
        done < <(cd "$repoRoot" && find "$archiveDir" -type f -print0 2>/dev/null)
        # Print one operation per line for the caller to read safely
        printf '%s\n' "${pruneOps[@]}"
    }

    # Collect files to normalize in specified directories
    collectNormalizeOps() {
        vlog 3 "collectNormalizeOps: repoRoot=$1 dirs=$(printf '%s ' "${dirs[@]}")"
        local repoRoot="$1"
        local dirs=("${@:2}")
        local normalizeOps=()
        for dir in "${dirs[@]}"; do
            [ ! -d "$repoRoot/$dir" ] && continue
            # Use NUL-delimited find to handle spaces/newlines in names
            while IFS= read -r -d '' filepath; do
                filepath="${filepath#./}"
                [ -z "$filepath" ] && continue
                local dirname filename base extension
                dirname=$(dirname "$filepath")
                filename=$(basename "$filepath")
                base="${filename%.*}"
                extension="${filename##*.}"
                [ "$extension" = "$filename" ] && extension=""
                # Extract timestamp
                local ts date time
                ts=$(extractTimestamp "$base")
                date="${ts%%|*}"; time="${ts##*|}"
                [ -z "$date" ] && date="$(date -r "$(stat -f '%m' "$repoRoot/$filepath" 2>/dev/null || echo 0)" '+%Y-%m-%d' 2>/dev/null || echo 'unknown')"
                [ -z "$time" ] && time="$(date -r "$(stat -f '%m' "$repoRoot/$filepath" 2>/dev/null || echo 0)" '+%H%M' 2>/dev/null || echo '0000')"
                local camelCaseName
                camelCaseName=$(toCamelCase "$base")
                local newFilename newPath
                if [ -n "$extension" ]; then
                    newFilename="${date}_${time}_${camelCaseName}.${extension}"
                else
                    newFilename="${date}_${time}_${camelCaseName}"
                fi
                newPath="${dirname}/${newFilename}"
                # Compliance: filename matches normalized pattern (yyyy-mm-dd_hhmm_CamelCase.ext)
                # Regex: Matches filenames like 2025-11-22_1234_MyFile.md or 2025-11-22_1234_MyFile.txt
                local compliantPattern='^[0-9]{4}-[0-9]{2}-[0-9]{2}_[0-9]{4}_[A-Z][A-Za-z0-9]*(\.[^.]+)?$' # yyyy-mm-dd_hhmm_CamelCase.ext
                if [[ ! "$filename" =~ $compliantPattern ]] && [ "$filepath" != "$newPath" ]; then
                    normalizeOps+=("$filepath|$newPath")
                fi
            done < <(cd "$repoRoot" && find "$dir" -type f -print0 2>/dev/null)
         done
        # Print one operation per line for the caller to read safely
        printf '%s\n' "${normalizeOps[@]}"
     }

    # Main logic
    vlog 1 "Options parsed: dryRun=$dryRun autoConfirm=$autoConfirm depth=$depth normalizeDirs=(${normalizeDirs[*]}) pruneDuration=$pruneDuration archiveDir=$archiveDir noTimestamp=$noTimestamp noCamelCase=$noCamelCase"
    local markdownFiles
    markdownFiles=$(findUntrackedMarkdown "$repoRoot" "$depth" "$inGitRepo")
    markdownFiles=$(normalizePaths "$markdownFiles")
    count=$(echo "$markdownFiles" | grep -c '^')
    vlog 1 "Discovered $count untracked markdown files in $repoRoot"
    vlog 2 "$markdownFiles"
    if [ -z "$markdownFiles" ]; then
        vlog 1 "No markdown files found, skipping untrackedOps loop."
    else
        local untrackedOps=()
        vlog 2 "Mapping each discovered markdown file to its intended archive destination"
        while IFS= read -r file; do
            [ -z "$file" ] && continue
            local base ext
            base=$(basename "$file")
            ext="${base##*.}"
            local ts date time
            ts=$(extractTimestamp "$base")
            date="${ts%%|*}"; time="${ts##*|}"
            if [ -z "$date" ]; then
                local btime mtime
                btime=$(stat -f "%B" "$file" 2>/dev/null || echo 0)
                mtime=$(stat -f "%m" "$file" 2>/dev/null || echo 0)
                date=$(date -r "${btime:-$mtime}" '+%Y-%m-%d' 2>/dev/null || echo "unknown")
                time=$(date -r "${btime:-$mtime}" '+%H%M' 2>/dev/null || echo "0000")
            fi
            local namePart
            if [ "$noCamelCase" -eq 1 ]; then
                namePart="${base%.*}"
            else
                namePart=$(toCamelCase "${base%.*}")
            fi
            local dest
            if [ "$noTimestamp" -eq 1 ]; then
                dest="$archiveDir/$namePart.$ext"
            else
                dest="$archiveDir/$date/${time}_${namePart}.$ext"
            fi
            untrackedOps+=("$file|$dest")
        done <<< "$markdownFiles"
    fi

    # NOTE: mapfile is NOT available in macOS's default /bin/bash.
    # Instead of: mapfile -t normalizeOps < <(collectNormalizeOps ...)
    normalizeOps=()
    while IFS= read -r line; do
        [ -n "$line" ] && normalizeOps+=("$line")
    done < <(collectNormalizeOps "$repoRoot" "${normalizeDirs[@]}")
    # Instead of: mapfile -t pruneOps < <(collectPruneOps ...)
    pruneOps=()
    if [ -n "$pruneDuration" ]; then
        while IFS= read -r line; do
            [ -n "$line" ] && pruneOps+=("$line")
        done < <(collectPruneOps "$repoRoot" "$pruneDuration" "$archiveDir")
    fi

    local totalOps=$(( ${#untrackedOps[@]} + ${#normalizeOps[@]} + ${#pruneOps[@]} ))
    [ "$totalOps" -eq 0 ] && echo "Executed 0 of 0 proposed operations" >&2 && exit 0

    local maxLen=0
    for op in "${untrackedOps[@]}" "${normalizeOps[@]}"; do
        local src="${op%%|*}"
        [ ${#src} -gt $maxLen ] && maxLen=${#src}
    done
    for file in "${pruneOps[@]}"; do
        [ ${#file} -gt $maxLen ] && maxLen=${#file}
    done

    # Display normalization operations first if present
    if [ ${#normalizeOps[@]} -gt 0 ]; then
        for op in "${normalizeOps[@]}"; do
            local src="${op%%|*}" dst="${op##*|}"
            printf "  %-${maxLen}s  →  %s\n" "$src" "$dst"
        done
    fi
    for op in "${untrackedOps[@]}"; do
        local src="${op%%|*}" dst="${op##*|}"
        printf "  %-${maxLen}s  →  %s\n" "$src" "$dst"
    done
    for file in "${pruneOps[@]}"; do
        printf "  %-${maxLen}s  →  [DELETE]\n" "$file"
    done

    if [ "${dryRun:-0}" -eq 1 ]; then
        echo "Dry-run: Executed 0 of $totalOps proposed operations" >&2
        exit 0
    fi

    if [ "${autoConfirm:-0}" -eq 0 ]; then
        # Prompt for single-character confirmation (y/Y to proceed)
        read -p "Proceed with these operations? [y/N] " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            echo "Cancelled." >&2
            echo "Executed 0 of $totalOps proposed operations" >&2
            exit 0
        fi
    fi

    local executedOps=0
    for op in "${normalizeOps[@]}"; do
        local src="${op%%|*}" dst="${op##*|}"
        local destDir
        destDir=$(dirname "$dst")
        mkdir -p "$destDir"
        if [ -f "$dst" ]; then
            printf "  ⚠ %-${maxLen}s  (destination exists)\n" "$src"
            continue
        fi
        if mv "$src" "$dst"; then
            executedOps=$((executedOps+1))
            printf "  ✓ %-${maxLen}s  →  %s\n" "$src" "$dst"
        else
            printf "  ⚠ %-${maxLen}s  (failed to move)\n" "$src" >&2
        fi
    done
    for op in "${untrackedOps[@]}"; do
        local src="${op%%|*}" dst="${op##*|}"
        local destDir
        destDir=$(dirname "$dst")
        mkdir -p "$destDir"
        if [ -f "$dst" ]; then
            printf "  ⚠ %-${maxLen}s  (destination exists)\n" "$src"
            continue
        fi
        if mv "$src" "$dst"; then
            executedOps=$((executedOps+1))
            printf "  ✓ %-${maxLen}s  →  %s\n" "$src" "$dst"
        else
            printf "  ⚠ %-${maxLen}s  (failed to move)\n" "$src" >&2
        fi
    done
    for file in "${pruneOps[@]}"; do
        if [ -f "$file" ] && rm "$file"; then
            executedOps=$((executedOps+1))
            printf "  ✓ %-${maxLen}s  →  [DELETED]\n" "$file"
        else
            printf "  ⚠ %-${maxLen}s  (failed to delete)\n" "$file" >&2
        fi
    done
    echo "Executed $executedOps of $totalOps proposed operations" >&2
}

main "$@"
