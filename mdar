#!/bin/bash

# mdar - Archive untracked markdown files into well-known locations with uniform naming
#
# Purpose: Untracked ephemeral markdown files created by AI agents are archived in
#          well-known locations with names that are uniform and sort temporally even 
#          in an IDE file tree with no sorting functionality.
#
# Actions:
#   - Move untracked markdown → aidocs/YYYY-MM-DD/HHMM_CamelCase.md
#   - When depth>=2: Also validate/normalize existing aidocs/ filenames
#   - Extract timestamps from filenames when present (e.g., 20251114-135621)
#   - Single confirmation prompt for all operations (unless -y/--yes is given)
#
# Options:
#   -n, --dry-run       Show proposed operations and exit (no prompt, no changes)
#   -y, --yes           Skip confirmation prompt and execute immediately
#   -v, --verbose       Show detailed debug information
#   -r, --recursive     Search all subdirectories recursively (unlimited depth)
#   --depth N           Directory depth to search (0=root only, 1=root+immediate subdirs, default: 2)
#
# Usage: mdar [-y|--yes] [-r|--recursive] [--depth N] [-n|--dry-run]

set -e

# Check if in git repo
if git rev-parse --git-dir > /dev/null 2>&1; then
    IN_GIT_REPO=1
    REPO_ROOT=$(git rev-parse --show-toplevel)
else
    IN_GIT_REPO=0
    REPO_ROOT=$(pwd)
fi
AUTO_CONFIRM=0
DEPTH=2
VERBOSE=0
DRY_RUN=0
# Parse arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -y|--yes)
            AUTO_CONFIRM=1
            shift
            ;;
        -r|--recursive)
            DEPTH=-1
            shift
            ;;
        --depth)
            if [[ -n "$2" && "$2" =~ ^[0-9]+$ ]]; then
                DEPTH="$2"
                shift 2
            else
                echo "Error: --depth requires a non-negative integer" >&2
                exit 1
            fi
            ;;
        -v|--verbose)
            VERBOSE=1
            shift
            ;;
        -n|--dry-run)
            DRY_RUN=1
            shift
            ;;
        *)
            echo "Unknown option: $1" >&2
            echo "Usage: mdar [-y|--yes] [-r|--recursive] [--depth N] [-v|--verbose] [-n|--dry-run]" >&2
            exit 1
            ;;
    esac
done

# After determining REPO_ROOT, switch to it so all subsequent path operations are relative and consistent
cd "$REPO_ROOT"

# Helper to print verbose commands to stderr
verbose_log() {
    if [ "$VERBOSE" -eq 1 ]; then
        echo "+ $*" >&2
    fi
}

# Find untracked markdown files based on depth setting
ALL_TO_AIDOCS=""
if [ "$IN_GIT_REPO" -eq 1 ]; then
    verbose_log git --no-pager -C "$REPO_ROOT" ls-files --others --exclude-standard
    # Use git status --porcelain as primary source, fallback to ls-files
    UNTRACKED_FROM_STATUS=$(git --no-pager -C "$REPO_ROOT" status --porcelain | grep '^?? ' | sed 's/^?? //' || true)
    UNTRACKED_FROM_LSFILES=$(git --no-pager -C "$REPO_ROOT" ls-files --others --exclude-standard || true)
    # Combine both sources and deduplicate
    ALL_UNTRACKED=$(printf "%s\n%s\n" "$UNTRACKED_FROM_STATUS" "$UNTRACKED_FROM_LSFILES" | sort | uniq | grep -v '^$' || true)

    if [ "$VERBOSE" -eq 1 ]; then
        echo "+ DEBUG: ALL_UNTRACKED files found:" >&2
        if [ -n "$ALL_UNTRACKED" ]; then
            echo "$ALL_UNTRACKED" | sed 's/^/+   /' >&2
        else
            echo "+   (none)" >&2
        fi
        echo "+ DEBUG: Total untracked file count: $(echo "$ALL_UNTRACKED" | grep -v '^$' | wc -l | tr -d ' ')" >&2
    fi

    # Filter markdown files by depth (exclude aidocs/)
    if [ "$DEPTH" -eq 0 ]; then
        # Only root level
        ALL_TO_AIDOCS=$(echo "$ALL_UNTRACKED" | grep -E '^[^/]+\.md$' | grep -v '^aidocs/' || true)
    elif [ "$DEPTH" -eq -1 ]; then
        # Unlimited depth - get all markdown files
        ALL_TO_AIDOCS=$(echo "$ALL_UNTRACKED" | grep '\.md$' | grep -v '^aidocs/' || true)
    else
        # Filter by depth: count slashes to determine directory level
        ALL_TO_AIDOCS=$(echo "$ALL_UNTRACKED" | grep '\.md$' | grep -v '^aidocs/' | awk -F'/' -v depth="$DEPTH" 'NF <= depth + 1' || true)
    fi

    if [ "$VERBOSE" -eq 1 ]; then
        echo "+ DEBUG: ALL_TO_AIDOCS count (depth=$DEPTH): $(echo "$ALL_TO_AIDOCS" | grep -v '^$' | wc -l | tr -d ' ')" >&2
    fi
else
    # Use find from the repo root for non-git repos
    if [ "$DEPTH" -eq -1 ]; then
        verbose_log "(cd $REPO_ROOT && find . -type f -name '*.md' 2>/dev/null | sed 's|^./||')"
        ALL_TO_AIDOCS=$(cd "$REPO_ROOT" && find . -type f -name '*.md' 2>/dev/null | sed 's|^./||' | grep -v '^aidocs/' || true)
    else
        verbose_log "(cd $REPO_ROOT && find . -maxdepth $((DEPTH + 1)) -type f -name '*.md' 2>/dev/null | sed 's|^./||')"
        ALL_TO_AIDOCS=$(cd "$REPO_ROOT" && find . -maxdepth $((DEPTH + 1)) -type f -name '*.md' 2>/dev/null | sed 's|^./||' | grep -v '^aidocs/' || true)
    fi
fi

# Normalize paths: ensure entries are relative to REPO_ROOT and not prefixed with './'
normalize_paths() {
    local in="$1"
    echo "$in" | sed -e 's|^\./||' -e 's|^$||' | grep -v '^$' || true
}

ALL_TO_AIDOCS=$(normalize_paths "$ALL_TO_AIDOCS")

# Categorize files by location
MARKDOWN_FILES=()
while IFS= read -r file; do
    [ -z "$file" ] && continue
    # Make sure file path is relative to REPO_ROOT
    if [ ! -f "$REPO_ROOT/$file" ]; then
        continue
    fi
    MARKDOWN_FILES+=("$file")
done <<< "$ALL_TO_AIDOCS"

# Verbose debug: dump the discovered files to stderr
if [ "$VERBOSE" -eq 1 ]; then
    echo "+ DEBUG: MARKDOWN_FILES to move to aidocs/:" >&2
    for f in "${MARKDOWN_FILES[@]}"; do echo "+   $f" >&2; done
fi

# Function to extract timestamp from filename
# Returns date in YYYY-MM-DD format and time in HHMM or HHMMSS format (or empty if not found)
# Sets global vars: EXTRACTED_DATE, EXTRACTED_TIME, and EXTRACTED_TIME_WITH_SECONDS
extract_timestamp_from_filename() {
    local filename="$1"
    EXTRACTED_DATE=""
    EXTRACTED_TIME=""
    EXTRACTED_TIME_WITH_SECONDS=""
    
    # Pattern 0: Our own format - YYYY-MM-DD_HHMMSS or YYYY-MM-DD_HHMM (already formatted)
    if [[ "$filename" =~ ([0-9]{4}-[0-9]{2}-[0-9]{2})_([0-9]{6}) ]]; then
        EXTRACTED_DATE="${BASH_REMATCH[1]}"
        EXTRACTED_TIME="${BASH_REMATCH[2]:0:4}"
        EXTRACTED_TIME_WITH_SECONDS="${BASH_REMATCH[2]}"
        return 0
    fi
    if [[ "$filename" =~ ([0-9]{4}-[0-9]{2}-[0-9]{2})_([0-9]{4}) ]]; then
        EXTRACTED_DATE="${BASH_REMATCH[1]}"
        EXTRACTED_TIME="${BASH_REMATCH[2]}"
        EXTRACTED_TIME_WITH_SECONDS=""
        return 0
    fi
    
    # Pattern 0.5: YYYYMMDD_HHMMSS or YYYYMMDD_HHMM (underscore, e.g., 20251115_003000 or 20251115_0030)
    if [[ "$filename" =~ ([0-9]{8})_([0-9]{6}) ]]; then
        EXTRACTED_DATE="${BASH_REMATCH[1]:0:4}-${BASH_REMATCH[1]:4:2}-${BASH_REMATCH[1]:6:2}"
        EXTRACTED_TIME="${BASH_REMATCH[2]:0:4}"
        EXTRACTED_TIME_WITH_SECONDS="${BASH_REMATCH[2]}"
        return 0
    fi
    if [[ "$filename" =~ ([0-9]{8})_([0-9]{4}) ]]; then
        EXTRACTED_DATE="${BASH_REMATCH[1]:0:4}-${BASH_REMATCH[1]:4:2}-${BASH_REMATCH[1]:6:2}"
        EXTRACTED_TIME="${BASH_REMATCH[2]}"
        EXTRACTED_TIME_WITH_SECONDS=""
        return 0
    fi

    # Pattern 1: YYYYMMDD-HHMMSS (e.g., 20251114-135621)
    if [[ "$filename" =~ ([0-9]{4})([0-9]{2})([0-9]{2})-([0-9]{2})([0-9]{2})([0-9]{2}) ]]; then
        EXTRACTED_DATE="${BASH_REMATCH[1]}-${BASH_REMATCH[2]}-${BASH_REMATCH[3]}"
        EXTRACTED_TIME="${BASH_REMATCH[4]}${BASH_REMATCH[5]}"
        EXTRACTED_TIME_WITH_SECONDS="${BASH_REMATCH[4]}${BASH_REMATCH[5]}${BASH_REMATCH[6]}"
        return 0
    fi
    
    # Pattern 2: YYYYMMDDHHMMSS (no dash, e.g., 20251114135621)
    if [[ "$filename" =~ ([0-9]{4})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2}) ]]; then
        EXTRACTED_DATE="${BASH_REMATCH[1]}-${BASH_REMATCH[2]}-${BASH_REMATCH[3]}"
        EXTRACTED_TIME="${BASH_REMATCH[4]}${BASH_REMATCH[5]}"
        EXTRACTED_TIME_WITH_SECONDS="${BASH_REMATCH[4]}${BASH_REMATCH[5]}${BASH_REMATCH[6]}"
        return 0
    fi
    
    # Pattern 3: YYYY-MM-DD-HHMMSS or YYYY-MM-DD-HH-MM-SS
    if [[ "$filename" =~ ([0-9]{4})-([0-9]{2})-([0-9]{2})-([0-9]{2})([0-9]{2})([0-9]{2}) ]]; then
        EXTRACTED_DATE="${BASH_REMATCH[1]}-${BASH_REMATCH[2]}-${BASH_REMATCH[3]}"
        EXTRACTED_TIME="${BASH_REMATCH[4]}${BASH_REMATCH[5]}"
        EXTRACTED_TIME_WITH_SECONDS="${BASH_REMATCH[4]}${BASH_REMATCH[5]}${BASH_REMATCH[6]}"
        return 0
    fi
    
    # Pattern 4: YYYY-MM-DD (date only)
    if [[ "$filename" =~ ([0-9]{4})-([0-9]{2})-([0-9]{2}) ]]; then
        EXTRACTED_DATE="${BASH_REMATCH[1]}-${BASH_REMATCH[2]}-${BASH_REMATCH[3]}"
        EXTRACTED_TIME="0000"
        EXTRACTED_TIME_WITH_SECONDS=""
        return 0
    fi
    
    # Pattern 5: YYYYMMDD (date only)
    if [[ "$filename" =~ ([0-9]{4})([0-9]{2})([0-9]{2}) ]]; then
        EXTRACTED_DATE="${BASH_REMATCH[1]}-${BASH_REMATCH[2]}-${BASH_REMATCH[3]}"
        EXTRACTED_TIME="0000"
        EXTRACTED_TIME_WITH_SECONDS=""
        return 0
    fi
    
    return 1
}

# Function to convert filename to CamelCase
# Also strips common timestamp patterns and extension from the name
to_camel_case() {
    local filename="$1"
    # Remove any extension first
    local base="${filename%.*}"
    
    # If no extension was removed (no dot in filename), use the whole filename
    if [ "$base" = "$filename" ]; then
        base="$filename"
    fi
    
    # Strip common timestamp patterns before CamelCase conversion
    # Pattern 1: YYYY-MM-DD_HHMMSS or YYYY-MM-DD_HHMM or YYYY-MM-DD (at start or anywhere with separator)
    base=$(echo "$base" | sed -E 's/[_-]?[0-9]{4}-[0-9]{2}-[0-9]{2}(_[0-9]{4,6})?[_-]?//g')
    # Pattern 2: YYYYMMDD-HHMMSS
    base=$(echo "$base" | sed -E 's/[_-]?[0-9]{8}-[0-9]{6}[_-]?//g')
    # Pattern 3: YYYYMMDDHHMMSS (no dash)
    base=$(echo "$base" | sed -E 's/[_-]?[0-9]{14}[_-]?//g')
    # Pattern 4: YYYYMMDD
    base=$(echo "$base" | sed -E 's/[_-]?[0-9]{8}[_-]?//g')
    
    # If already CamelCase (no underscores/hyphens), keep as-is
    if [[ ! "$base" =~ [_-] ]]; then
        # But capitalize first letter if it's lowercase
        echo "$(echo "${base:0:1}" | tr '[:lower:]' '[:upper:]')${base:1}"
        return
    fi
    
    # Convert to CamelCase:
    # - Replace underscores and hyphens with spaces
    # - Capitalize first letter of each word, lowercase the rest
    # - Remove spaces
    local result=$(echo "$base" | sed -e 's/[_-]/ /g' | \
        awk '{for(i=1;i<=NF;i++){$i=toupper(substr($i,1,1)) tolower(substr($i,2))}}1' | \
        sed 's/ //g')
    
    # Fix common acronyms and special cases (order matters - more specific first)
    result=$(echo "$result" | sed \
        -e 's/Alloydb/AlloyDB/g' \
        -e 's/Isam/ISAM/g' \
        -e 's/Iqs/IQS/g' \
        -e 's/Isbn/ISBN/g' \
        -e 's/Usitem/USItem/g' \
        -e 's/Gtin/GTIN/g' \
        -e 's/Upc/UPC/g' \
        -e 's/Wpid/WPID/g' \
        -e 's/Dgid/DGID/g' \
        -e 's/Vgid/VGID/g' \
        -e 's/\bIds$/IDs/g' \
        -e 's/\bId$/ID/g' \
        -e 's/\bId\b/ID/g' \
        -e 's/Api/API/g' \
        -e 's/Url/URL/g' \
        -e 's/Http/HTTP/g' \
        -e 's/Pr\([A-Z]\)/PR\1/g' \
        -e 's/\bGec\b/GEC/g' \
        -e 's/\bAdr\b/ADR/g' \
        -e 's/\bDb\b/DB/g' \
        -e 's/Sql/SQL/g' \
        -e 's/Json/JSON/g' \
        -e 's/Xml/XML/g' \
        -e 's/Ui/UI/g' \
        -e 's/Vp\b/VP/g' \
        -e 's/Virtualpack/VirtualPack/g' \
        -e 's/Hardbundle/HardBundle/g')
    
    echo "$result"
}
# Function to collect non-compliant filenames in aidocs/ (doesn't prompt or execute)
# Returns operations in the AIDOCS_OPERATIONS array
collect_aidocs_operations() {
    cd "$REPO_ROOT"

    # If aidocs doesn't exist, nothing to do
    if [ ! -d "$REPO_ROOT/aidocs" ]; then
        return 0
    fi

    verbose_log "(cd $REPO_ROOT && find aidocs -type f -name \"*.md\" 2>/dev/null | sed 's|^./||' | grep -v \"^aidocs/README.md\$\" | sort)"
    local aidocs_files
    aidocs_files=$(cd "$REPO_ROOT" && find aidocs -type f -name "*.md" 2>/dev/null | sed 's|^./||' | grep -v "^aidocs/README.md$" | sort || true)

    if [ -z "$aidocs_files" ]; then
        return 0
    fi

    while IFS= read -r filepath; do
        local dirname=$(dirname "$filepath")
        local filename=$(basename "$filepath")
        local base="${filename%.md}"
        
        # Check if filename already matches the compliant pattern: HHMM_CamelCase
        local is_filename_compliant=0
        if [[ "$base" =~ ^[0-9]{4}_[A-Z][A-Za-z0-9]*$ ]]; then
            is_filename_compliant=1
        fi
        
        # Extract date from directory path (aidocs/YYYY-MM-DD/)
        local dir_date=""
        if [[ "$dirname" =~ aidocs/([0-9]{4}-[0-9]{2}-[0-9]{2})$ ]]; then
            dir_date="${BASH_REMATCH[1]}"
        fi
        
        # If filename is compliant and in correct directory structure, skip it
        if [ $is_filename_compliant -eq 1 ] && [ -n "$dir_date" ]; then
            # File is already in correct format: aidocs/YYYY-MM-DD/HHMM_CamelCase.md
            continue
        fi
        
        # File needs normalization - determine correct date and time
        local date_part
        local time_part
        
        # Use directory date if available, otherwise extract from filename or use mtime
        if [ -n "$dir_date" ]; then
            date_part="$dir_date"
        else
            extract_timestamp_from_filename "$base" || true
            if [ -n "$EXTRACTED_DATE" ]; then
                date_part="$EXTRACTED_DATE"
            else
                local file_mtime=$(stat -f "%m" "$filepath" 2>/dev/null || echo 0)
                date_part=$(date -r "$file_mtime" '+%Y-%m-%d' 2>/dev/null || echo "unknown")
            fi
        fi
        
        # Extract time from filename if present
        if [ $is_filename_compliant -eq 1 ]; then
            # Filename is HHMM_CamelCase, extract the time
            time_part="${base:0:4}"
        else
            # Try to extract timestamp from filename
            extract_timestamp_from_filename "$base" || true
            if [ -n "$EXTRACTED_TIME" ]; then
                time_part="$EXTRACTED_TIME"
            else
                local file_mtime=$(stat -f "%m" "$filepath" 2>/dev/null || echo 0)
                time_part=$(date -r "$file_mtime" '+%H%M' 2>/dev/null || echo "0000")
            fi
        fi
        
        # Determine descriptive part
        local descriptive_part
        if [ $is_filename_compliant -eq 1 ]; then
            # Already HHMM_CamelCase, extract the CamelCase part after underscore
            descriptive_part="${base#*_}"
        else
            # Remove leading timestamp patterns from base
            descriptive_part="$base"
            descriptive_part=$(echo "$descriptive_part" | sed -E 's/^([0-9]{8}|[0-9]{4}-[0-9]{2}-[0-9]{2})[_-]?[0-9]{4,6}_//')
            # Also try to remove just HHMM_ pattern at start
            descriptive_part=$(echo "$descriptive_part" | sed -E 's/^[0-9]{4}_//')
            # Convert to CamelCase
            descriptive_part=$(to_camel_case "$descriptive_part.md")
            # Remove .md extension that to_camel_case added
            descriptive_part="${descriptive_part%.md}"
        fi
        
        local new_path="aidocs/${date_part}/${time_part}_${descriptive_part}.md"

        # Only add if the path actually changes
        if [ "$filepath" != "$new_path" ]; then
            AIDOCS_OPERATIONS+=("$filepath|$new_path")
        fi
    done <<< "$aidocs_files"
}


# Collect all operations into a single list
cd "$REPO_ROOT"

# Arrays to hold operations
declare -a AIDOCS_OPERATIONS    # Existing aidocs/ files to normalize: file|destination
declare -a UNTRACKED_OPERATIONS # Untracked files to move to aidocs/: file|destination

# First: Collect aidocs normalization operations (when depth >= 2 or unlimited)
if [ "$DEPTH" -ge 2 ] || [ "$DEPTH" -eq -1 ]; then
    collect_aidocs_operations
fi

# Second: Collect untracked markdown files to move
for file in "${MARKDOWN_FILES[@]}"; do
    BASENAME=$(basename "$file")
    
    # Try to extract timestamp from filename
    extract_timestamp_from_filename "$BASENAME" || true

    if [ -n "$EXTRACTED_DATE" ]; then
        DATETIME="$EXTRACTED_DATE"
        HHMM="$EXTRACTED_TIME"
    else
        # Fall back to file mtime (prefer birth time, fallback to mod time)
        BIRTH_TIME=$(stat -f "%B" "$file" 2>/dev/null || echo 0)
        MOD_TIME=$(stat -f "%m" "$file" 2>/dev/null || echo 0)
        
        BIRTH_DATE=$(date -r "$BIRTH_TIME" '+%Y-%m-%d' 2>/dev/null || echo "")
        MOD_DATE=$(date -r "$MOD_TIME" '+%Y-%m-%d' 2>/dev/null || echo "")
        
        # Use modtime if it's a different date than birthtime
        if [ "$BIRTH_DATE" != "$MOD_DATE" ] && [ -n "$MOD_DATE" ]; then
            USE_TIME="$MOD_TIME"
        else
            USE_TIME="$BIRTH_TIME"
        fi
        
        DATETIME=$(date -r "$USE_TIME" '+%Y-%m-%d' 2>/dev/null || echo "unknown")
        HHMM=$(date -r "$USE_TIME" '+%H%M' 2>/dev/null || echo "0000")
    fi
    
    # Convert to CamelCase (strips timestamps from the name)
    CAMEL=$(to_camel_case "$BASENAME")
    DEST="aidocs/$DATETIME/${HHMM}_${CAMEL}.md"
    
    UNTRACKED_OPERATIONS+=("$file|$DEST")
done

# Check if we have any operations to perform
TOTAL_OPS=$((${#AIDOCS_OPERATIONS[@]} + ${#UNTRACKED_OPERATIONS[@]}))
PROPOSED_OPS=$TOTAL_OPS
# Start executed counter at 0
EXECUTED_OPS=0

# If nothing to do, exit quietly
if [ $TOTAL_OPS -eq 0 ]; then
    echo "Executed 0 of 0 proposed operations" >&2
    exit 0
fi

# Display all proposed operations
if [ ${#AIDOCS_OPERATIONS[@]} -gt 0 ]; then
    for op in "${AIDOCS_OPERATIONS[@]}"; do
        SRC="${op%%|*}"
        DST="${op##*|}"
        echo "  $SRC  →  $DST"
    done
fi

if [ ${#UNTRACKED_OPERATIONS[@]} -gt 0 ]; then
    for op in "${UNTRACKED_OPERATIONS[@]}"; do
        SRC="${op%%|*}"
        DST="${op##*|}"
        echo "  $SRC  →  $DST"
    done
fi

# If dry-run mode, exit here without prompting or executing
if [ $DRY_RUN -eq 1 ]; then
    echo "Executed 0 of $PROPOSED_OPS proposed operations" >&2
    exit 0
fi

# Ask for confirmation unless -y flag (single prompt for all operations)
if [ $AUTO_CONFIRM -eq 0 ]; then
    read -p "Proceed with these operations? [y/N] " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo "Cancelled." >&2
        echo "Executed $EXECUTED_OPS of $PROPOSED_OPS proposed operations" >&2
        exit 0
    fi
fi

# Execute all operations
for op in "${AIDOCS_OPERATIONS[@]}" "${UNTRACKED_OPERATIONS[@]}"; do
    SRC="${op%%|*}"
    DST="${op##*|}"
    
    # Create destination directory
    DEST_DIR=$(dirname "$DST")
    mkdir -p "$DEST_DIR"
    
    # Check if destination already exists
    if [ -f "$REPO_ROOT/$DST" ]; then
        echo "  ⚠ Skipped (destination exists): $SRC"
        continue
    fi
    
    # Move/rename file
    if mv "$REPO_ROOT/$SRC" "$REPO_ROOT/$DST"; then
        EXECUTED_OPS=$((EXECUTED_OPS+1))
        echo "  ✓ Moved: $SRC → $DST"
    else
        echo "  ⚠ Failed to move: $SRC" >&2
    fi
done

# Final summary to stderr
echo "Executed $EXECUTED_OPS of $PROPOSED_OPS proposed operations" >&2
exit 0
