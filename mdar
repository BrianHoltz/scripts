#!/bin/bash
usageMsg="\
NAME
    mdar - Archive untracked markdown files as aidocs/YYYY-MM-DD/HHMM_CamelCase.md

SYNOPSIS
    mdar [--archive-dir DIR] [--no-timestamp] [--no-camelcase] [-y|--yes]
         [-r|--recursive] [--depth N] [--normalize DIR] [--prune DURATION]
         [-v|-vv|-vvv] [-x] [-n|--dry-run]

DESCRIPTION
    Archive untracked markdown files into dated folders, by default named
    aidocs/YYYY-MM-DD/HHMM_CamelCasedVersionOfOriginalName.md.
    This cleans up AI-generated docs, sorting them nicely in IDE folder viewers.

OPTIONS
    --archive-dir DIR
        Archive directory (default: aidocs)

    --no-timestamp
        Do not add HHMM time prefix to archived filenames

    --no-camelcase
        Do not convert filenames to CamelCase

    -n, --dry-run
        Show proposed operations and exit (no prompt, no changes)

    -y, --yes
        Skip confirmation prompt and execute immediately

    -v, -vv, -vvv
        Verbosity: -v=search/change files, -vv=+debug info, -vvv=+shell tracing

    -x
        Enable shell tracing (set -x)

    -r, --recursive
        Search all subdirectories recursively (unlimited depth)

    --depth N
        Directory depth to search (0=root only, default: 2)

    --normalize DIR
        Normalize files in DIR in-place (can be repeated, default: test-results)

    --prune DURATION
        Delete target files older than DURATION (e.g., 14d, 2w, 3m, 1y)
"
# usageMsg is intentionally placed at the very top for human readers and future agents.
# Do not move it inside functions.
set -e # Exit on error

main() {
    local autoConfirm=0
    local depth=2
    local verbose=0
    local dryRun=0
    local normalizeDirs=()
    local normalizeExplicit=0
    local pruneDuration=""
    local repoRoot
    local inGitRepo=0
    local archiveDir="aidocs"
    local noTimestamp=0
    local noCamelCase=0

    # Print to terminal a colorized version of the usage message.
    # AI agents must keep this function in sync with usageMsg above
    # by changing this function whenever usageMsg is changed.
    showUsage() {
        # Functional color variables
        local CMD_COLOR=$'\033[1;94m'         # Command name
        local OPTION_COLOR=$'\033[1;92m'      # Option flag
        local ARGVAL_COLOR=$'\033[1;38;5;208m'   # Option argument value
        local DEFAULT_COLOR=$'\033[1;95m'     # Default value
        local EMPHASIS_COLOR=$'\033[1;94m'    # Emphasis (e.g., set -x)
        local RESET=$'\033[0m'
        local BOLD=$'\033[1m'
        local UNDERLINE=$'\033[4m'

        printf "%b%bNAME%b\n" "$BOLD" "$UNDERLINE" "$RESET"
        printf "    %bmdar%b - Archive untracked markdown files as aidocs/YYYY-MM-DD/HHMM_CamelCase.md\n\n" "$CMD_COLOR" "$RESET"

        printf "%b%bSYNOPSIS%b\n" "$BOLD" "$UNDERLINE" "$RESET"
        printf "    %bmdar%b [%b--archive-dir%b %bDIR%b] [%b--no-timestamp%b] [%b--no-camelcase%b] [%b-y%b|%b--yes%b]\n" "$CMD_COLOR" "$RESET" "$OPTION_COLOR" "$RESET" "$ARGVAL_COLOR" "$RESET" "$OPTION_COLOR" "$RESET" "$OPTION_COLOR" "$RESET" "$OPTION_COLOR" "$RESET" "$OPTION_COLOR" "$RESET"
        printf "         [%b-r%b|%b--recursive%b] [%b--depth%b %bN%b] [%b--normalize%b %bDIR%b] [%b--prune%b %bDURATION%b]\n" "$OPTION_COLOR" "$RESET" "$OPTION_COLOR" "$RESET" "$OPTION_COLOR" "$RESET" "$ARGVAL_COLOR" "$RESET" "$OPTION_COLOR" "$RESET" "$ARGVAL_COLOR" "$RESET" "$OPTION_COLOR" "$RESET" "$ARGVAL_COLOR" "$RESET"
        printf "         [%b-v%b|%b-vv%b|%b-vvv%b] [%b-x%b] [%b-n%b|%b--dry-run%b]\n\n" "$OPTION_COLOR" "$RESET" "$OPTION_COLOR" "$RESET" "$OPTION_COLOR" "$RESET" "$OPTION_COLOR" "$RESET" "$OPTION_COLOR" "$RESET" "$OPTION_COLOR" "$RESET"
        printf "%b%bDESCRIPTION%b\n" "$BOLD" "$UNDERLINE" "$RESET"
        printf "    Archive untracked markdown files into dated folders, by default named\n"
        printf "    aidocs/YYYY-MM-DD/HHMM_CamelCasedVersionOfOriginalName.md.\n"
        printf "    This cleans up AI-generated docs, sorting them nicely in IDE folder viewers.\n\n"

        printf "%b%bOPTIONS%b\n" "$BOLD" "$UNDERLINE" "$RESET"
        printf "    %b--archive-dir%b %bDIR%b\n" "$OPTION_COLOR" "$RESET" "$ARGVAL_COLOR" "$RESET"
        printf "        Archive directory (default: %baidocs%b)\n\n" "$DEFAULT_COLOR" "$RESET"
        printf "    %b--no-timestamp%b\n" "$OPTION_COLOR" "$RESET"
        printf "        Do not add HHMM time prefix to archived filenames\n\n"
        printf "    %b--no-camelcase%b\n" "$OPTION_COLOR" "$RESET"
        printf "        Do not convert filenames to CamelCase\n\n"
        printf "    %b-n%b, %b--dry-run%b\n" "$OPTION_COLOR" "$RESET" "$OPTION_COLOR" "$RESET"
        printf "        Show proposed operations and exit (no prompt, no changes)\n\n"
        printf "    %b-y%b, %b--yes%b\n" "$OPTION_COLOR" "$RESET" "$OPTION_COLOR" "$RESET"
        printf "        Skip confirmation prompt and execute immediately\n\n"
        printf "    %b-v%b, %b-vv%b, %b-vvv%b\n" "$OPTION_COLOR" "$RESET" "$OPTION_COLOR" "$RESET" "$OPTION_COLOR" "$RESET"
        printf "        Verbosity: %b-v%b=search/change files, %b-vv%b=+debug info, %b-vvv%b=+shell tracing\n\n" "$OPTION_COLOR" "$RESET" "$OPTION_COLOR" "$RESET" "$OPTION_COLOR" "$RESET"
        printf "    %b-x%b\n" "$OPTION_COLOR" "$RESET"
        printf "        Enable shell tracing (%bset -x%b)\n\n" "$EMPHASIS_COLOR" "$RESET"
        printf "    %b-r%b, %b--recursive%b\n" "$OPTION_COLOR" "$RESET" "$OPTION_COLOR" "$RESET"
        printf "        Search all subdirectories recursively (unlimited depth)\n\n"
        printf "    %b--depth%b %bN%b\n" "$OPTION_COLOR" "$RESET" "$ARGVAL_COLOR" "$RESET"
        printf "        Directory depth to search (0=root only, default: %b2%b)\n\n" "$DEFAULT_COLOR" "$RESET"
        printf "    %b--normalize%b %bDIR%b\n" "$OPTION_COLOR" "$RESET" "$ARGVAL_COLOR" "$RESET"
        printf "        Normalize files in DIR in-place (can be repeated, default: %btest-results%b)\n\n" "$DEFAULT_COLOR" "$RESET"
        printf "    %b--prune%b %bDURATION%b\n" "$OPTION_COLOR" "$RESET" "$ARGVAL_COLOR" "$RESET"
        printf "        Delete target files older than %bDURATION%b (e.g., %b14d%b, %b2w%b, %b3m%b, %b1y%b)\n" "$ARGVAL_COLOR" "$RESET" "$ARGVAL_COLOR" "$RESET" "$ARGVAL_COLOR" "$RESET" "$ARGVAL_COLOR" "$RESET"
    }

    # Manual option parsing for macOS compatibility (BSD getopt doesn't support long options)
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --archive-dir)
                archiveDir="$2"; shift 2 ;;
            --no-timestamp)
                noTimestamp=1; shift ;;
            --no-camelcase)
                noCamelCase=1; shift ;;
            -n|--dry-run)
                dryRun=1; shift ;;
            -y|--yes)
                autoConfirm=1; shift ;;
            -r|--recursive)
                depth=-1; shift ;;
            --depth)
                depth="$2"; shift 2 ;;
            --normalize)
                normalizeDirs+=("$2"); normalizeExplicit=1; shift 2 ;;
            --prune)
                pruneDuration="$2"; shift 2 ;;
            -v|--verbose)
                verbose=$((verbose+1)); shift ;;
            -x)
                set -x; shift ;;
            -h|--help)
                showUsage; exit 0 ;;
            -H|--raw-help)
                printf "%s" "$usageMsg"; exit 0 ;;
            --)
                shift; break ;;
            -*)
                echo "Unknown option: $1" >&2
                showUsage >&2
                exit 1 ;;
            *)
                break ;;
        esac
    done

    if git rev-parse --git-dir > /dev/null 2>&1; then
        inGitRepo=1
        repoRoot=$(git rev-parse --show-toplevel)
    else
        repoRoot=$(pwd)
    fi
    cd "$repoRoot"

    # Helper to print verbose commands to stderr
    verboseLog() {
        local level="$1"; shift
        if [ "$verbose" -ge "$level" ]; then
            echo "+ $*" >&2
        fi
    }

    # Normalize paths: ensure entries are relative to repoRoot and not prefixed with './'
    normalizePaths() {
        local in="$1"
        echo "$in" | sed -e 's|^\./||' -e 's|^$||' | grep -v '^$' || true
    }

    # Find untracked markdown files based on depth setting
    findUntrackedMarkdown() {
        local repoRoot="$1"
        local depth="$2"
        local inGitRepo="$3"
        local files=""
        if [ "$inGitRepo" -eq 1 ]; then
            local statusFiles lsFiles
            statusFiles=$(git --no-pager -C "$repoRoot" status --porcelain | grep '^?? ' | sed 's/^?? //' || true)
            lsFiles=$(git --no-pager -C "$repoRoot" ls-files --others --exclude-standard || true)
            files=$(printf "%s\n%s\n" "$statusFiles" "$lsFiles" | sort | uniq | grep -v '^$' | grep '\.md$' | grep -v '^aidocs/')
            if [ "$depth" -ge 0 ]; then
                files=$(echo "$files" | awk -F'/' -v depth="$depth" 'NF <= depth + 1')
            fi
        else
            if [ "$depth" -eq -1 ]; then
                files=$(cd "$repoRoot" && find . -type f -name '*.md' 2>/dev/null | sed 's|^./||' | grep -v '^aidocs/')
            else
                files=$(cd "$repoRoot" && find . -maxdepth $((depth + 1)) -type f -name '*.md' 2>/dev/null | sed 's|^./||' | grep -v '^aidocs/')
            fi
        fi
        echo "$files"
    }

    # Extract timestamp from filename
    extractTimestamp() {
        local filename="$1"
        local date="" time=""
        # BASH_REMATCH is a bash array containing the full match and capture groups from the last successful regex match in [[ ... =~ ... ]].
        # BASH_REMATCH[0] is the full match, BASH_REMATCH[1] is the first capture group, BASH_REMATCH[2] is the second, etc.
        # Regex: Matches YYYY-MM-DD_HHMMSS or YYYY-MM-DD_HHMM
        if [[ "$filename" =~ ([0-9]{4}-[0-9]{2}-[0-9]{2})_([0-9]{6}) ]]; then
            date="${BASH_REMATCH[1]}"; time="${BASH_REMATCH[2]:0:4}"
        # Regex: Matches YYYY-MM-DD_HHMM
        elif [[ "$filename" =~ ([0-9]{4}-[0-9]{2}-[0-9]{2})_([0-9]{4}) ]]; then
            date="${BASH_REMATCH[1]}"; time="${BASH_REMATCH[2]}"
        # Regex: Matches YYYYMMDD_HHMMSS
        elif [[ "$filename" =~ ([0-9]{8})_([0-9]{6}) ]]; then
            date="${BASH_REMATCH[1]:0:4}-${BASH_REMATCH[1]:4:2}-${BASH_REMATCH[1]:6:2}"; time="${BASH_REMATCH[2]:0:4}"
        # Regex: Matches YYYYMMDD_HHMM
        elif [[ "$filename" =~ ([0-9]{8})_([0-9]{4}) ]]; then
            date="${BASH_REMATCH[1]:0:4}-${BASH_REMATCH[1]:4:2}-${BASH_REMATCH[1]:6:2}"; time="${BASH_REMATCH[2]}"
        # Regex: Matches YYYYMMDD-HHMMSS
        elif [[ "$filename" =~ ([0-9]{4})([0-9]{2})([0-9]{2})-([0-9]{2})([0-9]{2})([0-9]{2}) ]]; then
            date="${BASH_REMATCH[1]}-${BASH_REMATCH[2]}-${BASH_REMATCH[3]}"; time="${BASH_REMATCH[4]}${BASH_REMATCH[5]}"
        # Regex: Matches YYYYMMDDHHMMSS
        elif [[ "$filename" =~ ([0-9]{4})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2}) ]]; then
            date="${BASH_REMATCH[1]}-${BASH_REMATCH[2]}-${BASH_REMATCH[3]}"; time="${BASH_REMATCH[4]}${BASH_REMATCH[5]}"
        # Regex: Matches YYYY-MM-DD-HHMMSS
        elif [[ "$filename" =~ ([0-9]{4})-([0-9]{2})-([0-9]{2})-([0-9]{2})([0-9]{2})([0-9]{2}) ]]; then
            date="${BASH_REMATCH[1]}-${BASH_REMATCH[2]}-${BASH_REMATCH[3]}"; time="${BASH_REMATCH[4]}${BASH_REMATCH[5]}"
        # Regex: Matches YYYY-MM-DD
        elif [[ "$filename" =~ ([0-9]{4})-([0-9]{2})-([0-9]{2}) ]]; then
            date="${BASH_REMATCH[1]}-${BASH_REMATCH[2]}-${BASH_REMATCH[3]}"; time="0000"
        # Regex: Matches YYYYMMDD
        elif [[ "$filename" =~ ([0-9]{4})([0-9]{2})([0-9]{2}) ]]; then
            date="${BASH_REMATCH[1]}-${BASH_REMATCH[2]}-${BASH_REMATCH[3]}"; time="0000"
        fi
        echo "$date|$time"
    }

    # Convert filename to CamelCase, stripping timestamps
    toCamelCase() {
        local filename="$1"
        local base="${filename%.*}"
        base=$(echo "$base" | sed -E 's/[_-]?[0-9]{4}-[0-9]{2}-[0-9]{2}(_[0-9]{4,6})?[_-]?//g')
        base=$(echo "$base" | sed -E 's/[_-]?[0-9]{8}-[0-9]{6}[_-]?//g')
        base=$(echo "$base" | sed -E 's/[_-]?[0-9]{14}[_-]?//g')
        base=$(echo "$base" | sed -E 's/[_-]?[0-9]{8}[_-]?//g')
        if [[ ! "$base" =~ [_-] ]]; then
            if [[ "$base" =~ ^[A-Z0-9]+$ ]]; then
                echo "$(echo "$base" | awk '{print toupper(substr($0,1,1)) tolower(substr($0,2))}')"
            else
                echo "$(echo "${base:0:1}" | tr '[:lower:]' '[:upper:]')${base:1}"
            fi
            return
        fi
        echo "$base" | sed -e 's/[_-]/ /g' | awk '{for(i=1;i<=NF;i++){$i=toupper(substr($i,1,1)) tolower(substr($i,2))}}1' | sed 's/ //g'
    }

    # Parse duration string to seconds
    parseDurationToSeconds() {
        local duration="$1"
        local num="${duration%[dwmy]}"
        local unit="${duration#$num}"
        [ -z "$unit" ] && unit="d"
        case "$unit" in
            d) echo $((num * 86400)) ;;
            w) echo $((num * 7 * 86400)) ;;
            m) echo $((num * 30 * 86400)) ;;
            y) echo $((num * 365 * 86400)) ;;
            *) echo "Invalid duration unit: $unit" >&2; return 1 ;;
        esac
    }

    # Collect files to prune
    collectPruneOps() {
        local repoRoot="$1" duration="$2" archiveDir="$3"
        local cutoffTime
        cutoffTime=$(($(date +%s) - $(parseDurationToSeconds "$duration")))
        local files
        # Find all files in the archive directory, excluding README.md
        files=$(cd "$repoRoot" && find "$archiveDir" -type f 2>/dev/null | sed 's|^./||' | grep -v "^${archiveDir}/README.md$" || true)
        local pruneOps=()
        for f in $files; do
            local mtime
            mtime=$(stat -f "%m" "$repoRoot/$f" 2>/dev/null || echo 0)
            [ "$mtime" -lt "$cutoffTime" ] && pruneOps+=("$f")
        done
        echo "${pruneOps[@]}"
    }

    # Collect files to normalize in specified directories
    collectNormalizeOps() {
        local repoRoot="$1"
        local dirs=("${@:2}")
        local normalizeOps=()
        for dir in "${dirs[@]}"; do
            [ ! -d "$repoRoot/$dir" ] && continue
            local files
            files=$(cd "$repoRoot" && find "$dir" -type f 2>/dev/null | sed 's|^./||' || true)
            for filepath in $files; do
                [ -z "$filepath" ] && continue
                local dirname filename base extension
                dirname=$(dirname "$filepath")
                filename=$(basename "$filepath")
                base="${filename%.*}"
                extension="${filename##*.}"
                [ "$extension" = "$filename" ] && extension=""
                # Extract timestamp
                local ts date time
                ts=$(extractTimestamp "$base")
                date="${ts%%|*}"; time="${ts##*|}"
                [ -z "$date" ] && date=$(date -r $(stat -f "%m" "$repoRoot/$filepath" 2>/dev/null || echo 0) '+%Y-%m-%d' 2>/dev/null || echo "unknown")
                [ -z "$time" ] && time=$(date -r $(stat -f "%m" "$repoRoot/$filepath" 2>/dev/null || echo 0) '+%H%M' 2>/dev/null || echo "0000")
                local camelCaseName
                camelCaseName=$(toCamelCase "$base")
                local newFilename newPath
                if [ -n "$extension" ]; then
                    newFilename="${date}_${time}_${camelCaseName}.${extension}"
                else
                    newFilename="${date}_${time}_${camelCaseName}"
                fi
                newPath="${dirname}/${newFilename}"
                # Compliance: filename matches normalized pattern (yyyy-mm-dd_hhmm_CamelCase.ext)
                # Regex: Matches filenames like 2025-11-22_1234_MyFile.md or 2025-11-22_1234_MyFile.txt
                local compliantPattern='^[0-9]{4}-[0-9]{2}-[0-9]{2}_[0-9]{4}_[A-Z][A-Za-z0-9]*(\.[^.]+)?$' # yyyy-mm-dd_hhmm_CamelCase.ext
                if [[ ! "$filename" =~ $compliantPattern ]] && [ "$filepath" != "$newPath" ]; then
                    normalizeOps+=("$filepath|$newPath")
                fi
            done
        done
        echo "${normalizeOps[@]}"
    }

    # Main logic
    verboseLog 1 "Options parsed: dryRun=$dryRun autoConfirm=$autoConfirm depth=$depth normalizeDirs=(${normalizeDirs[@]}) pruneDuration=$pruneDuration archiveDir=$archiveDir noTimestamp=$noTimestamp noCamelCase=$noCamelCase"
    verboseLog 1 "Searching for untracked markdown files..."
    local markdownFiles
    markdownFiles=$(findUntrackedMarkdown "$repoRoot" "$depth" "$inGitRepo")
    verboseLog 1 "Found markdown files: $markdownFiles"
    markdownFiles=$(normalizePaths "$markdownFiles")
    verboseLog 1 "Normalized markdown file paths: $markdownFiles"

    if [ -z "$markdownFiles" ]; then
        verboseLog 1 "No markdown files found, skipping untrackedOps loop."
    else
        local untrackedOps=()
        verboseLog 1 "Building untrackedOps array..."
        while IFS= read -r file; do
            [ -z "$file" ] && continue
            local base ext
            base=$(basename "$file")
            ext="${base##*.}"
            local ts date time
            ts=$(extractTimestamp "$base")
            date="${ts%%|*}"; time="${ts##*|}"
            if [ -z "$date" ]; then
                local btime mtime
                btime=$(stat -f "%B" "$file" 2>/dev/null || echo 0)
                mtime=$(stat -f "%m" "$file" 2>/dev/null || echo 0)
                date=$(date -r "${btime:-$mtime}" '+%Y-%m-%d' 2>/dev/null || echo "unknown")
                time=$(date -r "${btime:-$mtime}" '+%H%M' 2>/dev/null || echo "0000")
            fi
            local namePart
            if [ "$noCamelCase" -eq 1 ]; then
                namePart="${base%.*}"
            else
                namePart=$(toCamelCase "${base%.*}")
            fi
            local dest
            if [ "$noTimestamp" -eq 1 ]; then
                dest="$archiveDir/$namePart.$ext"
            else
                dest="$archiveDir/$date/${time}_${namePart}.$ext"
            fi
            untrackedOps+=("$file|$dest")
        done <<< "$markdownFiles"
        verboseLog 1 "Built untrackedOps: ${untrackedOps[@]}"
    fi

    local normalizeOps=()
    if [ "$normalizeExplicit" -eq 1 ] && [ ${#normalizeDirs[@]} -gt 0 ]; then
        normalizeOps=($(collectNormalizeOps "$repoRoot" "${normalizeDirs[@]}"))
    fi

    local pruneOps=()
    [ -n "$pruneDuration" ] && pruneOps=($(collectPruneOps "$repoRoot" "$pruneDuration" "$archiveDir"))

    local totalOps=$(( ${#untrackedOps[@]} + ${#normalizeOps[@]} + ${#pruneOps[@]} ))
    [ "$totalOps" -eq 0 ] && echo "Executed 0 of 0 proposed operations" >&2 && exit 0

    local maxLen=0
    for op in "${untrackedOps[@]}" "${normalizeOps[@]}"; do
        local src="${op%%|*}"
        [ ${#src} -gt $maxLen ] && maxLen=${#src}
    done
    for file in "${pruneOps[@]}"; do
        [ ${#file} -gt $maxLen ] && maxLen=${#file}
    done

    # Display normalization operations first if present
    if [ ${#normalizeOps[@]} -gt 0 ]; then
        for op in "${normalizeOps[@]}"; do
            local src="${op%%|*}" dst="${op##*|}"
            printf "  %-${maxLen}s  →  %s\n" "$src" "$dst"
        done
    fi
    for op in "${untrackedOps[@]}"; do
        local src="${op%%|*}" dst="${op##*|}"
        printf "  %-${maxLen}s  →  %s\n" "$src" "$dst"
    done
    for file in "${pruneOps[@]}"; do
        printf "  %-${maxLen}s  →  [DELETE]\n" "$file"
    done

    # If dry-run was requested, never prompt: print summary and exit immediately.
    if [ "${dryRun:-0}" -eq 1 ]; then
        echo "Dry-run: Executed 0 of $totalOps proposed operations" >&2
        exit 0
    fi

    # If autoConfirm was not set, ask the user. Note: dry-run already returned above.
    if [ "${autoConfirm:-0}" -eq 0 ]; then
        # Prompt for single-character confirmation (y/Y to proceed)
        read -p "Proceed with these operations? [y/N] " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            echo "Cancelled." >&2
            echo "Executed 0 of $totalOps proposed operations" >&2
            exit 0
        fi
    fi

    local executedOps=0
    for op in "${normalizeOps[@]}"; do
        local src="${op%%|*}" dst="${op##*|}"
        local destDir
        destDir=$(dirname "$dst")
        mkdir -p "$destDir"
        if [ -f "$dst" ]; then
            printf "  ⚠ %-${maxLen}s  (destination exists)\n" "$src"
            continue
        fi
        if mv "$src" "$dst"; then
            executedOps=$((executedOps+1))
            printf "  ✓ %-${maxLen}s  →  %s\n" "$src" "$dst"
        else
            printf "  ⚠ %-${maxLen}s  (failed to move)\n" "$src" >&2
        fi
    done
    for op in "${untrackedOps[@]}"; do
        local src="${op%%|*}" dst="${op##*|}"
        local destDir
        destDir=$(dirname "$dst")
        mkdir -p "$destDir"
        if [ -f "$dst" ]; then
            printf "  ⚠ %-${maxLen}s  (destination exists)\n" "$src"
            continue
        fi
        if mv "$src" "$dst"; then
            executedOps=$((executedOps+1))
            printf "  ✓ %-${maxLen}s  →  %s\n" "$src" "$dst"
        else
            printf "  ⚠ %-${maxLen}s  (failed to move)\n" "$src" >&2
        fi
    done
    for file in "${pruneOps[@]}"; do
        if [ -f "$file" ] && rm "$file"; then
            executedOps=$((executedOps+1))
            printf "  ✓ %-${maxLen}s  →  [DELETED]\n" "$file"
        else
            printf "  ⚠ %-${maxLen}s  (failed to delete)\n" "$file" >&2
        fi
    done
    echo "Executed $executedOps of $totalOps proposed operations" >&2
}

main "$@"
