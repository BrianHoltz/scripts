#!/bin/bash

# mdar - Archive untracked markdown files into well-known locations with uniform naming
#
# Purpose: Untracked ephemeral markdown files created by AI agents are archived in
#          well-known locations with names that are uniform and sort temporally even 
#          in an IDE file tree with no sorting functionality.
#
# Actions:
#   - Move root, docs/, & scripts/ untracked markdown → aidocs/YYYY-MM-DD/HHMM_CamelCase.md
#   - Rename test-results/ text files in place → YYYY-MM-DD_HHMMSS_CamelCase.ext
#   - With --deep, move all other untracked markdown → aidocs/YYYY-MM-DD/HHMM_CamelCase.md
#   - Extract timestamps from filenames when present (e.g., 20251114-135621)
#   - Never updates filesystem without confirmation (unless -y/--yes is given)
#
# Options:
#   -n, --dry-run    Show proposed operations and exit (no prompt, no changes)
#   -y, --yes        Skip confirmation prompt and execute immediately
#   -v, --verbose    Show detailed debug information
#   --deep           Also search for markdown files in non-standard locations
#
# Usage: mdar [-y|--yes] [--deep] [-n|--dry-run]

set -e

# Check if in git repo
if git rev-parse --git-dir > /dev/null 2>&1; then
    IN_GIT_REPO=1
    REPO_ROOT=$(git rev-parse --show-toplevel)
else
    IN_GIT_REPO=0
    REPO_ROOT=$(pwd)
fi
AUTO_CONFIRM=0
DEEP_SEARCH=0
VERBOSE=0
DRY_RUN=0
# Parse arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -y|--yes)
            AUTO_CONFIRM=1
            shift
            ;;
        --deep)
            DEEP_SEARCH=1
            shift
            ;;
        -v|--verbose)
            VERBOSE=1
            shift
            ;;
        -n|--dry-run)
            DRY_RUN=1
            shift
            ;;
        *)
            echo "Unknown option: $1" >&2
            echo "Usage: mdar [-y|--yes] [--deep] [-v|--verbose] [-n|--dry-run]" >&2
            exit 1
            ;;
    esac
done

# After determining REPO_ROOT, switch to it so all subsequent path operations are relative and consistent
cd "$REPO_ROOT"

# Helper to print verbose commands to stderr
verbose_log() {
    if [ "$VERBOSE" -eq 1 ]; then
        echo "+ $*" >&2
    fi
}

# Find untracked markdown files in root, docs/, and scripts/ (always). Run commands from REPO_ROOT.
ROOT_UNTRACKED_MD=""
DOCS_UNTRACKED_MD=""
SCRIPTS_UNTRACKED_MD=""
if [ "$IN_GIT_REPO" -eq 1 ]; then
    verbose_log git --no-pager -C "$REPO_ROOT" ls-files --others --exclude-standard
    # Use git status --porcelain as primary source, fallback to ls-files
    UNTRACKED_FROM_STATUS=$(git --no-pager -C "$REPO_ROOT" status --porcelain | grep '^?? ' | sed 's/^?? //' || true)
    UNTRACKED_FROM_LSFILES=$(git --no-pager -C "$REPO_ROOT" ls-files --others --exclude-standard || true)
    # Combine both sources and deduplicate
    ALL_UNTRACKED=$(printf "%s\n%s\n" "$UNTRACKED_FROM_STATUS" "$UNTRACKED_FROM_LSFILES" | sort | uniq | grep -v '^$' || true)

    if [ "$VERBOSE" -eq 1 ]; then
        echo "+ DEBUG: ALL_UNTRACKED files found:" >&2
        if [ -n "$ALL_UNTRACKED" ]; then
            echo "$ALL_UNTRACKED" | sed 's/^/+   /' >&2
        else
            echo "+   (none)" >&2
        fi
        echo "+ DEBUG: Total untracked file count: $(echo "$ALL_UNTRACKED" | grep -v '^$' | wc -l | tr -d ' ')" >&2
    fi

    ROOT_UNTRACKED_MD=$(echo "$ALL_UNTRACKED" | grep -E '^[^/]+\.md$' | grep -v '^aidocs/' | grep -v '^docs/' | grep -v '^scripts/' | grep -v '^test-results/' || true)
    DOCS_UNTRACKED_MD=$(echo "$ALL_UNTRACKED" | grep -E '^docs/.*\.md$' | grep -v '^aidocs/' || true)
    SCRIPTS_UNTRACKED_MD=$(echo "$ALL_UNTRACKED" | grep -E '^scripts/.*\.md$' || true)

    if [ "$VERBOSE" -eq 1 ]; then
        echo "+ DEBUG: ROOT_UNTRACKED_MD count: $(echo "$ROOT_UNTRACKED_MD" | grep -v '^$' | wc -l | tr -d ' ')" >&2
        echo "+ DEBUG: DOCS_UNTRACKED_MD count: $(echo "$DOCS_UNTRACKED_MD" | grep -v '^$' | wc -l | tr -d ' ')" >&2
        echo "+ DEBUG: SCRIPTS_UNTRACKED_MD count: $(echo "$SCRIPTS_UNTRACKED_MD" | grep -v '^$' | wc -l | tr -d ' ')" >&2
    fi
else
    # Use find from the repo root and strip leading ./ so results match git's output style
    verbose_log "(cd $REPO_ROOT && find . -type f 2>/dev/null | sed 's|^./||')"
    # Get all files for non-git repos
    ALL_UNTRACKED=$(cd "$REPO_ROOT" && find . -type f 2>/dev/null | sed 's|^./||' || true)

    ROOT_UNTRACKED_MD=$(echo "$ALL_UNTRACKED" | grep -E '^[^/]+\.md$' | grep -v '^aidocs/' | grep -v '^docs/' | grep -v '^scripts/' | grep -v '^test-results/' || true)
    DOCS_UNTRACKED_MD=$(echo "$ALL_UNTRACKED" | grep -E '^docs/.*\.md$' | grep -v '^aidocs/' || true)
    SCRIPTS_UNTRACKED_MD=$(echo "$ALL_UNTRACKED" | grep -E '^scripts/.*\.md$' || true)
fi

# If --deep, find untracked markdown anywhere else (excluding aidocs/, docs/, scripts/, test-results/, and root)
DEEP_UNTRACKED_MD=""
if [ "$DEEP_SEARCH" -eq 1 ]; then
    if [ "$IN_GIT_REPO" -eq 1 ]; then
        verbose_log git --no-pager -C "$REPO_ROOT" ls-files --others --exclude-standard '\.md$'
        # ALL_UNTRACKED was already computed above
        DEEP_UNTRACKED_MD=$(echo "$ALL_UNTRACKED" | grep '\.md$' | grep -v '^aidocs/' | grep -v '^docs/' | grep -v '^scripts/' | grep -v '^test-results/' | grep -v '^[^/]*\.md$' || true)
    else
        verbose_log "(cd $REPO_ROOT && find . -type f -name '*.md' 2>/dev/null | sed 's|^./||')"
        DEEP_UNTRACKED_MD=$(cd "$REPO_ROOT" && find . -type f -name '*.md' 2>/dev/null | sed 's|^./||' | grep -v '^aidocs/' | grep -v '^docs/' | grep -v '^scripts/' | grep -v '^test-results/' | grep -v '^[^/]*\.md$' || true)
    fi
fi

# Always get all untracked test-results/ files
if [ "$IN_GIT_REPO" -eq 1 ]; then
    verbose_log "git --no-pager -C $REPO_ROOT ls-files --others --exclude-standard | grep '^test-results/'"
    # ALL_UNTRACKED was already computed above
    ALL_UNTRACKED_TEST_RESULTS=$(echo "$ALL_UNTRACKED" | grep '^test-results/' || true)
else
    if [ -d "$REPO_ROOT/test-results" ]; then
        verbose_log "(cd $REPO_ROOT && find ./test-results -type f 2>/dev/null | sed 's|^./||')"
        ALL_UNTRACKED_TEST_RESULTS=$(cd "$REPO_ROOT" && find ./test-results -type f 2>/dev/null | sed 's|^./||' || true)
    else
        ALL_UNTRACKED_TEST_RESULTS=""
    fi
fi

# Build list of files to move to aidocs/
ALL_TO_AIDOCS="${ROOT_UNTRACKED_MD}
${DOCS_UNTRACKED_MD}
${SCRIPTS_UNTRACKED_MD}"
if [ "$DEEP_SEARCH" -eq 1 ]; then
    ALL_TO_AIDOCS="${ALL_TO_AIDOCS}
${DEEP_UNTRACKED_MD}"
fi
ALL_TO_AIDOCS=$(echo "$ALL_TO_AIDOCS" | grep -v '^$' | sort | uniq)

# Normalize paths: ensure entries are relative to REPO_ROOT and not prefixed with './'
normalize_paths() {
    local in="$1"
    echo "$in" | sed -e 's|^\./||' -e 's|^$||' | grep -v '^$' || true
}

ALL_TO_AIDOCS=$(normalize_paths "$ALL_TO_AIDOCS")
ALL_UNTRACKED_TEST_RESULTS=$(normalize_paths "$ALL_UNTRACKED_TEST_RESULTS")

# Categorize files by location
ROOT_AND_DOCS_FILES=()
TEST_RESULTS_FILES=()
while IFS= read -r file; do
    [ -z "$file" ] && continue
    # Make sure file path is relative to REPO_ROOT
    if [ ! -f "$REPO_ROOT/$file" ]; then
        continue
    fi
    ROOT_AND_DOCS_FILES+=("$file")
done <<< "$ALL_TO_AIDOCS"

for file in $ALL_UNTRACKED_TEST_RESULTS; do
    [ -z "$file" ] && continue
    if [ -f "$REPO_ROOT/$file" ]; then
        TEST_RESULTS_FILES+=("$file")
    fi
done

# Verbose debug: dump the discovered files to stderr
if [ "$VERBOSE" -eq 1 ]; then
    echo "+ DEBUG: ROOT_AND_DOCS_FILES (includes scripts/):" >&2
    for f in "${ROOT_AND_DOCS_FILES[@]}"; do echo "+   $f" >&2; done
    echo "+ DEBUG: TEST_RESULTS_FILES:" >&2
    for f in "${TEST_RESULTS_FILES[@]}"; do echo "+   $f" >&2; done
fi

# Function to extract timestamp from filename
# Returns date in YYYY-MM-DD format and time in HHMM or HHMMSS format (or empty if not found)
# Sets global vars: EXTRACTED_DATE, EXTRACTED_TIME, and EXTRACTED_TIME_WITH_SECONDS
extract_timestamp_from_filename() {
    local filename="$1"
    EXTRACTED_DATE=""
    EXTRACTED_TIME=""
    EXTRACTED_TIME_WITH_SECONDS=""
    
    # Pattern 0: Our own format - YYYY-MM-DD_HHMMSS or YYYY-MM-DD_HHMM (already formatted)
    if [[ "$filename" =~ ([0-9]{4}-[0-9]{2}-[0-9]{2})_([0-9]{6}) ]]; then
        EXTRACTED_DATE="${BASH_REMATCH[1]}"
        EXTRACTED_TIME="${BASH_REMATCH[2]:0:4}"
        EXTRACTED_TIME_WITH_SECONDS="${BASH_REMATCH[2]}"
        return 0
    fi
    if [[ "$filename" =~ ([0-9]{4}-[0-9]{2}-[0-9]{2})_([0-9]{4}) ]]; then
        EXTRACTED_DATE="${BASH_REMATCH[1]}"
        EXTRACTED_TIME="${BASH_REMATCH[2]}"
        EXTRACTED_TIME_WITH_SECONDS=""
        return 0
    fi
    
    # Pattern 0.5: YYYYMMDD_HHMMSS or YYYYMMDD_HHMM (underscore, e.g., 20251115_003000 or 20251115_0030)
    if [[ "$filename" =~ ([0-9]{8})_([0-9]{6}) ]]; then
        EXTRACTED_DATE="${BASH_REMATCH[1]:0:4}-${BASH_REMATCH[1]:4:2}-${BASH_REMATCH[1]:6:2}"
        EXTRACTED_TIME="${BASH_REMATCH[2]:0:4}"
        EXTRACTED_TIME_WITH_SECONDS="${BASH_REMATCH[2]}"
        return 0
    fi
    if [[ "$filename" =~ ([0-9]{8})_([0-9]{4}) ]]; then
        EXTRACTED_DATE="${BASH_REMATCH[1]:0:4}-${BASH_REMATCH[1]:4:2}-${BASH_REMATCH[1]:6:2}"
        EXTRACTED_TIME="${BASH_REMATCH[2]}"
        EXTRACTED_TIME_WITH_SECONDS=""
        return 0
    fi

    # Pattern 1: YYYYMMDD-HHMMSS (e.g., 20251114-135621)
    if [[ "$filename" =~ ([0-9]{4})([0-9]{2})([0-9]{2})-([0-9]{2})([0-9]{2})([0-9]{2}) ]]; then
        EXTRACTED_DATE="${BASH_REMATCH[1]}-${BASH_REMATCH[2]}-${BASH_REMATCH[3]}"
        EXTRACTED_TIME="${BASH_REMATCH[4]}${BASH_REMATCH[5]}"
        EXTRACTED_TIME_WITH_SECONDS="${BASH_REMATCH[4]}${BASH_REMATCH[5]}${BASH_REMATCH[6]}"
        return 0
    fi
    
    # Pattern 2: YYYYMMDDHHMMSS (no dash, e.g., 20251114135621)
    if [[ "$filename" =~ ([0-9]{4})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2}) ]]; then
        EXTRACTED_DATE="${BASH_REMATCH[1]}-${BASH_REMATCH[2]}-${BASH_REMATCH[3]}"
        EXTRACTED_TIME="${BASH_REMATCH[4]}${BASH_REMATCH[5]}"
        EXTRACTED_TIME_WITH_SECONDS="${BASH_REMATCH[4]}${BASH_REMATCH[5]}${BASH_REMATCH[6]}"
        return 0
    fi
    
    # Pattern 3: YYYY-MM-DD-HHMMSS or YYYY-MM-DD-HH-MM-SS
    if [[ "$filename" =~ ([0-9]{4})-([0-9]{2})-([0-9]{2})-([0-9]{2})([0-9]{2})([0-9]{2}) ]]; then
        EXTRACTED_DATE="${BASH_REMATCH[1]}-${BASH_REMATCH[2]}-${BASH_REMATCH[3]}"
        EXTRACTED_TIME="${BASH_REMATCH[4]}${BASH_REMATCH[5]}"
        EXTRACTED_TIME_WITH_SECONDS="${BASH_REMATCH[4]}${BASH_REMATCH[5]}${BASH_REMATCH[6]}"
        return 0
    fi
    
    # Pattern 4: YYYY-MM-DD (date only)
    if [[ "$filename" =~ ([0-9]{4})-([0-9]{2})-([0-9]{2}) ]]; then
        EXTRACTED_DATE="${BASH_REMATCH[1]}-${BASH_REMATCH[2]}-${BASH_REMATCH[3]}"
        EXTRACTED_TIME="0000"
        EXTRACTED_TIME_WITH_SECONDS=""
        return 0
    fi
    
    # Pattern 5: YYYYMMDD (date only)
    if [[ "$filename" =~ ([0-9]{4})([0-9]{2})([0-9]{2}) ]]; then
        EXTRACTED_DATE="${BASH_REMATCH[1]}-${BASH_REMATCH[2]}-${BASH_REMATCH[3]}"
        EXTRACTED_TIME="0000"
        EXTRACTED_TIME_WITH_SECONDS=""
        return 0
    fi
    
    return 1
}

# Function to convert filename to CamelCase
# Also strips common timestamp patterns and extension from the name
to_camel_case() {
    local filename="$1"
    # Remove any extension first
    local base="${filename%.*}"
    
    # If no extension was removed (no dot in filename), use the whole filename
    if [ "$base" = "$filename" ]; then
        base="$filename"
    fi
    
    # Strip common timestamp patterns before CamelCase conversion
    # Pattern 1: YYYY-MM-DD_HHMMSS or YYYY-MM-DD_HHMM or YYYY-MM-DD (at start or anywhere with separator)
    base=$(echo "$base" | sed -E 's/[_-]?[0-9]{4}-[0-9]{2}-[0-9]{2}(_[0-9]{4,6})?[_-]?//g')
    # Pattern 2: YYYYMMDD-HHMMSS
    base=$(echo "$base" | sed -E 's/[_-]?[0-9]{8}-[0-9]{6}[_-]?//g')
    # Pattern 3: YYYYMMDDHHMMSS (no dash)
    base=$(echo "$base" | sed -E 's/[_-]?[0-9]{14}[_-]?//g')
    # Pattern 4: YYYYMMDD
    base=$(echo "$base" | sed -E 's/[_-]?[0-9]{8}[_-]?//g')
    
    # If already CamelCase (no underscores/hyphens), keep as-is
    if [[ ! "$base" =~ [_-] ]]; then
        # But capitalize first letter if it's lowercase
        echo "$(echo "${base:0:1}" | tr '[:lower:]' '[:upper:]')${base:1}"
        return
    fi
    
    # Convert to CamelCase:
    # - Replace underscores and hyphens with spaces
    # - Capitalize first letter of each word, lowercase the rest
    # - Remove spaces
    local result=$(echo "$base" | sed -e 's/[_-]/ /g' | \
        awk '{for(i=1;i<=NF;i++){$i=toupper(substr($i,1,1)) tolower(substr($i,2))}}1' | \
        sed 's/ //g')
    
    # Fix common acronyms and special cases (order matters - more specific first)
    result=$(echo "$result" | sed \
        -e 's/Alloydb/AlloyDB/g' \
        -e 's/Isam/ISAM/g' \
        -e 's/Iqs/IQS/g' \
        -e 's/Isbn/ISBN/g' \
        -e 's/Usitem/USItem/g' \
        -e 's/Gtin/GTIN/g' \
        -e 's/Upc/UPC/g' \
        -e 's/Wpid/WPID/g' \
        -e 's/Dgid/DGID/g' \
        -e 's/Vgid/VGID/g' \
        -e 's/\bIds$/IDs/g' \
        -e 's/\bId$/ID/g' \
        -e 's/\bId\b/ID/g' \
        -e 's/Api/API/g' \
        -e 's/Url/URL/g' \
        -e 's/Http/HTTP/g' \
        -e 's/Pr\([A-Z]\)/PR\1/g' \
        -e 's/\bGec\b/GEC/g' \
        -e 's/\bAdr\b/ADR/g' \
        -e 's/\bDb\b/DB/g' \
        -e 's/Sql/SQL/g' \
        -e 's/Json/JSON/g' \
        -e 's/Xml/XML/g' \
        -e 's/Ui/UI/g' \
        -e 's/Vp\b/VP/g' \
        -e 's/Virtualpack/VirtualPack/g' \
        -e 's/Hardbundle/HardBundle/g')
    
    echo "$result"
}

# Function to normalize an aidocs filename to proper format
normalize_aidocs_filename() {
    local filename="$1"
    local base="${filename%.md}"
    
    # Check if it already matches the pattern hhmm_CamelCase
    if [[ "$base" =~ ^[0-9]{4}_[A-Z][A-Za-z0-9]*$ ]]; then
        # Already compliant
        echo "$filename"
        return
    fi
    
    # Extract time prefix if present
    local time_prefix=""
    local descriptive=""
    
    if [[ "$base" =~ ^([0-9]{4})_(.+)$ ]]; then
        time_prefix="${BASH_REMATCH[1]}"
        descriptive="${BASH_REMATCH[2]}"
    else
        # No time prefix - use file's modification time
        descriptive="$base"
    fi
    
    # Normalize the descriptive part
    # Check if it's all lowercase with hyphens (like api-kafka-research-plan)
    local normalized_test=$(echo "$descriptive" | sed -e 's/[-_]//g')
    
    if [[ "$normalized_test" =~ ^[a-z0-9]+$ ]]; then
        # All lowercase - need to convert to CamelCase
        normalized=$(to_camel_case "${descriptive}.md")
    elif [[ "$normalized_test" =~ ^[A-Z0-9]+$ ]]; then
        # All uppercase - need to convert to CamelCase
        normalized=$(to_camel_case "${descriptive}.md")
    else
        # Mixed case - just remove separators, but check for all-caps words
        # Replace sequences like "BREAKTHROUGH-" or "SUMMARY_" with proper case
        normalized="$descriptive"
        
        # For each all-caps word followed by separator, convert to proper case
        while [[ "$normalized" =~ ([A-Z]{3,})([-_]) ]]; do
            local caps_word="${BASH_REMATCH[1]}"
            local separator="${BASH_REMATCH[2]}"
            local proper_word=$(echo "$caps_word" | awk '{print toupper(substr($0,1,1)) tolower(substr($0,2))}')
            normalized=$(echo "$normalized" | sed "s/${caps_word}${separator}/${proper_word}/")
        done
        
        # Also handle all-caps words at the end
        if [[ "$normalized" =~ ([A-Z]{3,})$ ]]; then
            local caps_word="${BASH_REMATCH[1]}"
            local proper_word=$(echo "$caps_word" | awk '{print toupper(substr($0,1,1)) tolower(substr($0,2))}')
            normalized=$(echo "$normalized" | sed "s/${caps_word}$/${proper_word}/")
        fi
        
        # Now remove remaining separators
        normalized=$(echo "$normalized" | sed -e 's/[-_]//g')
    fi
    
    # If we have a time prefix, use it; otherwise return just the normalized part
    if [ -n "$time_prefix" ]; then
        echo "${time_prefix}_${normalized}.md"
    else
        echo "${normalized}.md"
    fi
}

# Function to check and fix non-compliant filenames in aidocs/
check_aidocs_filenames() {
    cd "$REPO_ROOT"

    # If aidocs doesn't exist, nothing to do
    if [ ! -d "$REPO_ROOT/aidocs" ]; then
        return 0
    fi

    verbose_log "(cd $REPO_ROOT && find aidocs -type f -name \"*.md\" 2>/dev/null | sed 's|^./||' | grep -v \"^aidocs/README.md\$\" | sort)"
    local aidocs_files
    aidocs_files=$(cd "$REPO_ROOT" && find aidocs -type f -name "*.md" 2>/dev/null | sed 's|^./||' | grep -v "^aidocs/README.md$" | sort || true)

    if [ -z "$aidocs_files" ]; then
        return 0
    fi

    declare -a RENAMES

    while IFS= read -r filepath; do
        local filename=$(basename "$filepath")
        local base="${filename%.md}"
        local dirname=$(dirname "$filepath")

        # Extract date and time from filename, or fallback to mtime
        extract_timestamp_from_filename "$base" || true
        local date_part
        local time_part
        if [ -n "$EXTRACTED_DATE" ]; then
            date_part="$EXTRACTED_DATE"
            if [ -n "$EXTRACTED_TIME" ]; then
                time_part="$EXTRACTED_TIME"
            else
                local file_mtime=$(stat -f "%m" "$filepath" 2>/dev/null || echo 0)
                time_part=$(date -r "$file_mtime" '+%H%M' 2>/dev/null || echo "0000")
            fi
        else
            local file_mtime=$(stat -f "%m" "$filepath" 2>/dev/null || echo 0)
            date_part=$(date -r "$file_mtime" '+%Y-%m-%d' 2>/dev/null || echo "unknown")
            time_part=$(date -r "$file_mtime" '+%H%M' 2>/dev/null || echo "0000")
        fi
        # Normalize descriptive part
        # Remove leading date and time (YYYYMMDD[_-]HHMM[SS]_ or YYYY-MM-DD[_-]HHMM[SS]_) if present
        local descriptive_part="$base"
        # Remove leading date and time (YYYYMMDD[_-]HHMM[SS]_ or YYYY-MM-DD[_-]HHMM[SS]_) if present
        descriptive_part=$(echo "$descriptive_part" | sed -E 's/^([0-9]{8}|[0-9]{4}-[0-9]{2}-[0-9]{2})[_-]?[0-9]{4,6}_//')
        local camel_case_name=$(to_camel_case "$descriptive_part.md")
        local new_path="aidocs/${date_part}/${time_part}_${camel_case_name}.md"

        # Only add if the name or path actually changes
        if [ "$filepath" != "$new_path" ]; then
            RENAMES+=("$filepath|$new_path")
        fi
    done <<< "$aidocs_files"
    
    if [ ${#RENAMES[@]} -eq 0 ]; then
        return 0
    fi
    
    # Display proposed renames/moves
    for rename in "${RENAMES[@]}"; do
        local src="${rename%%|*}"
        local dst="${rename##*|}"
        echo "  $src"
        echo "    → $dst"
        echo ""
    done
    
    # Ask for confirmation unless -y flag
    if [ $AUTO_CONFIRM -eq 0 ]; then
        read -p "Proceed with these renames? [y/N] " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            echo "Cancelled."
            echo ""
            return 0
        fi
    fi
    
    # Execute renames/moves
    echo "Renaming/moving files..."
    for rename in "${RENAMES[@]}"; do
        local src="${rename%%|*}"
        local dst="${rename##*|}"
        local dst_dir=$(dirname "$dst")
        mkdir -p "$dst_dir"
        if [ -f "$dst" ]; then
            echo "  ⚠ Skipped (destination exists): $src"
            continue
        fi
        mv "$src" "$dst"
        echo "  ✓ Moved: $src → $dst"
    done
    
    echo ""
    echo "Done! Renamed/moved ${#RENAMES[@]} file(s) in aidocs/."
    return 0
}

# Function to check and fix non-compliant filenames in docs/
check_docs_filenames() {
    cd "$REPO_ROOT"

    # If docs doesn't exist, nothing to do
    if [ ! -d "$REPO_ROOT/docs" ]; then
        return 0
    fi

    verbose_log "(cd $REPO_ROOT && find docs -type f -name \"*.md\" 2>/dev/null | sed 's|^./||' | grep -v \"^docs/README.md\$\" | sort)"
    local docs_files
    docs_files=$(cd "$REPO_ROOT" && find docs -type f -name "*.md" 2>/dev/null | sed 's|^./||' | grep -v "^docs/README.md$" | sort || true)

    if [ -z "$docs_files" ]; then
        return 0
    fi

    declare -a RENAMES

    while IFS= read -r filepath; do
        local dirname=$(dirname "$filepath")
        local filename=$(basename "$filepath")
        local base="${filename%.md}"
        
        # Check if filename is compliant: CamelCase.md pattern (no hyphens, underscores, or all-caps words)
        # Compliant = starts with uppercase, uses CamelCase, no hyphens/underscores
        local is_compliant=1
        
        # Has hyphens
        if [[ "$base" =~ - ]]; then
            is_compliant=0
        # Has underscores
        elif [[ "$base" =~ _ ]]; then
            is_compliant=0
        # All-caps words (multiple consecutive uppercase letters that aren't acronyms like API, DB, etc.)
        # We'll be lenient with 3-letter acronyms but flag longer all-caps sequences
        elif [[ "$base" =~ [A-Z]{4,} ]]; then
            is_compliant=0
        # All lowercase
        elif [[ "$base" =~ ^[a-z] ]]; then
            is_compliant=0
        fi
        
        if [ $is_compliant -eq 0 ]; then
            # Generate normalized filename - just CamelCase, no time prefix
            local new_filename=$(to_camel_case "$filename")
            local new_path="${dirname}/${new_filename}.md"
            
            # Only add if the name actually changes
            if [ "$filepath" != "$new_path" ]; then
                RENAMES+=("$filepath|$new_path")
            fi
        fi
    done <<< "$docs_files"
    
    if [ ${#RENAMES[@]} -eq 0 ]; then
        return 0
    fi
    
    # Display proposed renames
    for rename in "${RENAMES[@]}"; do
        local src="${rename%%|*}"
        local dst="${rename##*|}"
        echo "  $src"
        echo "    → $(basename "$dst")"
        echo ""
    done
    
    # Ask for confirmation unless -y flag
    if [ $AUTO_CONFIRM -eq 0 ]; then
        read -p "Proceed with these renames? [y/N] " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            echo "Cancelled."
            echo ""
            return 0
        fi
    fi
    
    # Execute renames
    echo "Renaming files..."
    for rename in "${RENAMES[@]}"; do
        local src="${rename%%|*}"
        local dst="${rename##*|}"
        
        # Check if destination already exists
        if [ -f "$dst" ]; then
            echo "  ⚠ Skipped (destination exists): $src"
            continue
        fi
        
        # Rename file
        mv "$src" "$dst"
        echo "  ✓ Renamed: $(basename "$src") → $(basename "$dst")"
    done
    
    echo ""
    echo "Done! Renamed ${#RENAMES[@]} file(s) in docs/."
    return 0
}

# By default, check both aidocs compliance AND untracked files
# Only skip aidocs check if --untracked-only is specified

AIDOCS_RENAMED=0
DOCS_RENAMED=0
UNTRACKED_MOVED=0

# First, check aidocs/ for non-compliant filenames (unless --untracked-only)
# DISABLED: These functions are buggy and create multiple prompts
# check_aidocs_filenames
# AIDOCS_RENAMED=$?

# check_docs_filenames
# DOCS_RENAMED=$?

# Then, find untracked files
cd "$REPO_ROOT"

# (All untracked files were already collected above into ROOT_AND_DOCS_FILES and TEST_RESULTS_FILES)
# No further repo-wide find/ls invocation is needed here; avoid extra output and potential find errors.

# Build list of operations
declare -a MOVES_TO_AIDOCS      # file|destination
declare -a RENAMES_IN_PLACE     # file|newname

# Process root, docs/, and other files → move to aidocs/
for file in "${ROOT_AND_DOCS_FILES[@]}"; do
    # Get just the filename (no path)
    BASENAME=$(basename "$file")
    

    # Try to extract timestamp from filename
    extract_timestamp_from_filename "$BASENAME" || true

    if [ -n "$EXTRACTED_DATE" ]; then
        # Use extracted timestamp from filename
        DATETIME="$EXTRACTED_DATE"
        HHMM="$EXTRACTED_TIME"
    else
        # Fall back to file mtime
        BIRTH_TIME=$(stat -f "%B" "$file" 2>/dev/null || echo 0)
        MOD_TIME=$(stat -f "%m" "$file" 2>/dev/null || echo 0)
        
        # Extract dates
        BIRTH_DATE=$(date -r "$BIRTH_TIME" '+%Y-%m-%d' 2>/dev/null || echo "")
        MOD_DATE=$(date -r "$MOD_TIME" '+%Y-%m-%d' 2>/dev/null || echo "")
        
        # Use modtime if it's a different date than birthtime, otherwise use birthtime
        if [ "$BIRTH_DATE" != "$MOD_DATE" ] && [ -n "$MOD_DATE" ]; then
            USE_TIME="$MOD_TIME"
        else
            USE_TIME="$BIRTH_TIME"
        fi
        
        # Format datetime
        DATETIME=$(date -r "$USE_TIME" '+%Y-%m-%d' 2>/dev/null || echo "unknown")
        HHMM=$(date -r "$USE_TIME" '+%H%M' 2>/dev/null || echo "0000")
    fi
    
    # Convert to CamelCase (this will strip timestamps from the name)
    CAMEL=$(to_camel_case "$BASENAME")
    
    # Build destination path
    DEST="aidocs/$DATETIME/${HHMM}_${CAMEL}.md"
    
    MOVES_TO_AIDOCS+=("$file|$DEST")
done

# Process test-results/ files → rename in place
# First pass: collect all potential names with HHMM format and detect collisions
declare -a POTENTIAL_NAMES
declare -a COLLISION_FILES

for file in "${TEST_RESULTS_FILES[@]}"; do
    BASENAME=$(basename "$file")
    extract_timestamp_from_filename "$BASENAME" || true

    if [ -n "$EXTRACTED_DATE" ]; then
        DATETIME="$EXTRACTED_DATE"
        if [ -n "$EXTRACTED_TIME" ]; then
            TIME_HHMM="${EXTRACTED_TIME}"
        else
            MOD_TIME=$(stat -f "%m" "$file" 2>/dev/null || echo 0)
            TIME_HHMM=$(date -r "$MOD_TIME" '+%H%M' 2>/dev/null || echo "0000")
        fi
    else
        MOD_TIME=$(stat -f "%m" "$file" 2>/dev/null || echo 0)
        DATETIME=$(date -r "$MOD_TIME" '+%Y-%m-%d' 2>/dev/null || echo "unknown")
        TIME_HHMM=$(date -r "$MOD_TIME" '+%H%M' 2>/dev/null || echo "0000")
    fi
    
    CAMEL=$(to_camel_case "$BASENAME")
    POTENTIAL_NAME="${DATETIME}_${TIME_HHMM}_${CAMEL}"
    
    # Check if this name already exists in our list
    FOUND_COLLISION=0
    for existing in "${POTENTIAL_NAMES[@]}"; do
        if [ "$existing" = "$POTENTIAL_NAME" ]; then
            FOUND_COLLISION=1
            # Mark this file and the previous matching file as needing seconds
            COLLISION_FILES+=("$file")
            break
        fi
    done
    
    if [ $FOUND_COLLISION -eq 0 ]; then
        POTENTIAL_NAMES+=("$POTENTIAL_NAME")
    fi
done

# Second pass: actually rename files
for file in "${TEST_RESULTS_FILES[@]}"; do
    DIRNAME=$(dirname "$file")
    BASENAME=$(basename "$file")
    FILENAME="${BASENAME%.*}"
    EXTENSION="${BASENAME##*.}"
    
    # Handle files without extensions
    if [ "$EXTENSION" = "$BASENAME" ]; then
        EXTENSION=""
    fi
    
    # Check if this file needs seconds to avoid collision
    NEEDS_SECONDS=0
    for collision_file in "${COLLISION_FILES[@]}"; do
        if [ "$file" = "$collision_file" ]; then
            NEEDS_SECONDS=1
            break
        fi
    done
    
    # Try to extract timestamp from filename first
    extract_timestamp_from_filename "$BASENAME" || true

    if [ -n "$EXTRACTED_DATE" ]; then
        # Use extracted timestamp from filename
        DATETIME="$EXTRACTED_DATE"
        if [ -n "$EXTRACTED_TIME_WITH_SECONDS" ] && [ $NEEDS_SECONDS -eq 1 ]; then
            # Has seconds and needs them for collision avoidance
            TIME_PREFIX="${DATETIME}_${EXTRACTED_TIME_WITH_SECONDS}"
        elif [ -n "$EXTRACTED_TIME" ] && [ "$EXTRACTED_TIME" != "0000" ]; then
            # Use HHMM format
            TIME_PREFIX="${DATETIME}_${EXTRACTED_TIME}"
        else
            # No time in filename - use modtime for time portion
            MOD_TIME=$(stat -f "%m" "$file" 2>/dev/null || echo 0)
            HHMM=$(date -r "$MOD_TIME" '+%H%M' 2>/dev/null || echo "0000")
            TIME_PREFIX="${DATETIME}_${HHMM}"
        fi
    else
        # Fall back to file mtime for both date and time
        MOD_TIME=$(stat -f "%m" "$file" 2>/dev/null || echo 0)
        DATETIME=$(date -r "$MOD_TIME" '+%Y-%m-%d' 2>/dev/null || echo "unknown")
        HHMM=$(date -r "$MOD_TIME" '+%H%M' 2>/dev/null || echo "0000")
        TIME_PREFIX="${DATETIME}_${HHMM}"
    fi
    
    # Convert filename to CamelCase (this will strip timestamps from the name)
    CAMEL=$(to_camel_case "$BASENAME")
    
    # Build new filename with extension
    if [ -n "$EXTENSION" ]; then
        NEW_BASENAME="${TIME_PREFIX}_${CAMEL}.${EXTENSION}"
    else
        NEW_BASENAME="${TIME_PREFIX}_${CAMEL}"
    fi
    
    # Check if already compliant AND optimal (can't be simplified)
    # Compliant format: YYYY-MM-DD_HHMM_CamelCase.ext or YYYY-MM-DD_HHMMSS_CamelCase.ext
    # Time portion is REQUIRED (not optional)
    is_compliant=0
    if [ -n "$EXTENSION" ]; then
        # Check if filename matches and whether we can simplify it
        if [[ "$FILENAME" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}_[0-9]{4,6}_[A-Z][A-Za-z0-9]*$ ]]; then
            # File is compliant, but check if we can drop seconds
            if [[ "$FILENAME" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}_[0-9]{6}_ ]]; then
                # Has seconds - only compliant if file needs seconds for collision avoidance
                if [ $NEEDS_SECONDS -eq 1 ]; then
                    is_compliant=1
                else
                    is_compliant=0  # Can be simplified
                fi
            else
                # HHMM format - always compliant
                is_compliant=1
            fi
        fi
    else
        if [[ "$BASENAME" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}_[0-9]{4,6}_[A-Z][A-Za-z0-9]*$ ]]; then
            if [[ "$BASENAME" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}_[0-9]{6}_ ]]; then
                if [ $NEEDS_SECONDS -eq 1 ]; then
                    is_compliant=1
                else
                    is_compliant=0
                fi
            else
                is_compliant=1
            fi
        fi
    fi
    
    if [ $is_compliant -eq 0 ]; then
        NEW_PATH="${DIRNAME}/${NEW_BASENAME}"
        
        if [ "$file" != "$NEW_PATH" ]; then
            RENAMES_IN_PLACE+=("$file|$NEW_PATH")
        fi
    fi
done

# Check if we have any operations to perform
TOTAL_OPS=$((${#MOVES_TO_AIDOCS[@]} + ${#RENAMES_IN_PLACE[@]}))
PROPOSED_OPS=$TOTAL_OPS
# Start executed counter at 0
EXECUTED_OPS=0

# If nothing to do, print summary to stderr and exit
if [ $TOTAL_OPS -eq 0 ]; then
    SUMMARY_PRINTED=1
    echo "Executed $EXECUTED_OPS of $PROPOSED_OPS proposed file moves/renames" >&2
    exit 0
fi

# Display proposed operations
if [ ${#MOVES_TO_AIDOCS[@]} -gt 0 ]; then
    for move in "${MOVES_TO_AIDOCS[@]}"; do
        SRC="${move%%|*}"
        DST="${move##*|}"
        echo "  $SRC  →  $DST"
    done
fi

if [ ${#RENAMES_IN_PLACE[@]} -gt 0 ]; then
    for rename in "${RENAMES_IN_PLACE[@]}"; do
        SRC="${rename%%|*}"
        DST="${rename##*|}"
        echo "  $(basename "$SRC")  →  $(basename "$DST")"
    done
fi

# If dry-run mode, exit here without prompting or executing
if [ $DRY_RUN -eq 1 ]; then
    echo "Executed 0 of $PROPOSED_OPS proposed file moves/renames" >&2
    exit 0
fi

# Ask for confirmation unless -y flag
if [ $AUTO_CONFIRM -eq 0 ]; then
    read -p "Proceed with these operations? [y/N] " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        # User cancelled; print summary to stderr and exit
        SUMMARY_PRINTED=1
        echo "Executed $EXECUTED_OPS of $PROPOSED_OPS proposed file moves/renames" >&2
        exit 0
    fi
fi

# Execute moves to aidocs/
if [ ${#MOVES_TO_AIDOCS[@]} -gt 0 ]; then
    for move in "${MOVES_TO_AIDOCS[@]}"; do
        SRC="${move%%|*}"
        DST="${move##*|}"
        
        # Create destination directory
        DEST_DIR=$(dirname "$DST")
        mkdir -p "$DEST_DIR"
        
        # Move file (use REPO_ROOT-qualified paths)
        if mv "$REPO_ROOT/$SRC" "$REPO_ROOT/$DST"; then
            EXECUTED_OPS=$((EXECUTED_OPS+1))
            echo "  ✓ Moved: $SRC → $DST"
        else
            echo "  ⚠ Failed to move: $SRC" >&2
        fi
    done
fi

# Execute renames in place
if [ ${#RENAMES_IN_PLACE[@]} -gt 0 ]; then
    for rename in "${RENAMES_IN_PLACE[@]}"; do
        SRC="${rename%%|*}"
        DST="${rename##*|}"
        
        # Check if destination already exists
        if [ -f "$REPO_ROOT/$DST" ]; then
            echo "  ⚠ Skipped (destination exists): $(basename "$SRC")"
            continue
        fi
        
        # Rename file (use REPO_ROOT-qualified paths)
        if mv "$REPO_ROOT/$SRC" "$REPO_ROOT/$DST"; then
            EXECUTED_OPS=$((EXECUTED_OPS+1))
            echo "  ✓ Renamed: $(basename "$SRC") → $(basename "$DST")"
        else
            echo "  ⚠ Failed to rename: $(basename "$SRC")" >&2
        fi
    done
fi

# Final summary to stderr
SUMMARY_PRINTED=1
echo "Executed $EXECUTED_OPS of $PROPOSED_OPS proposed file moves/renames" >&2
exit 0
