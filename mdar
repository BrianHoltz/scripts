#!/usr/bin/env bash
usageMsg="\
NAME
    mdar - Archive untracked markdown files as aidocs/YYYY-MM-DD/hhmm_CamelCase.md

SYNOPSIS
    mdar [--archive DIR] [--normalize DIR] [--ignore DIR] [--depth N] [-r|--recursive]
        [--no-timestamp] [--no-camelcase] [--prune N<mhdwMy>]
        [-n|--dry-run] [-y|--yes] [-i|--interactive] [-l|--long] [-v|-vv|-vvv] [-x]

DESCRIPTION
    Archive untracked markdown files into dated folders, by default normalized to
    aidocs/YYYY-MM-DD/hhmm_CamelCasedVersionOfOriginalName.md.
    This cleans up AI-generated docs, sorting them temporally in IDE folder viewers.
    Files inside YYYY-MM-DD/HHMM/ directories are exempt from filename normalization
    (useful to cluster fraternal-sibling files).
    Files inside YYYY-MM-DD/ directories are kept in place, and if they have
    a HHMM prefix it is preserved.

    Ignore patterns can be specified via --ignore flag or in mdar_ignore file (one
    pattern per line, # for comments). Patterns match directory names and filenames.

OPTIONS
    --archive DIR       Archive to this directory (default: aidocs/)
    --normalize DIR     Normalize DIR in-place    (default: test-results/, repeatable)
    --ignore PATTERN    Ignore dirs/files matching PATTERN (default: 2delete/, repeatable)
                        Also reads patterns from mdar_ignore (one per line, # comments)
    --depth N           Directory depth to search (default: 2, root only: 0)
    -r, --recursive     Search all subdirectories recursively (depth=∞)
    --no-timestamp      Do not normalize filenames by adding hhmm create-time prefix
    --no-camelcase      Do not normalize filenames by changing to CamelCase
    --prune N<mhdwMy>   Delete target files older than e.g., 30d, 4w, 1M
    -n, --dry-run       Show proposed mv/rm operations and exit (no prompt, no changes)
    -y, --yes           Skip confirmation prompt, execute mv/rm operations immediately
    -i, --interactive   Prompt for confirmation on each individual operation
    -l, --long          Show birthtime and modtime columns in output (long format)
    -v, -vv, -vvv       Logging level: 1: what, 2: +how (find/git/mv/rm), 3: +debug
    -x                  Enable shell tracing (set -x)

EXAMPLE OUTPUT
  HTTP_RESPONSE_COMPATIBILITY.md            →  aidocs/2025-11-22/1520_HTTPResponseCompatibility.md
  test-results/HTTP_200_vs_400.md           →  test-results/2025-11-22_1530_HTTP200Vs400.md
  aidocs/2015-11-01/request_signing_fix.md  →  [DELETE]
"

# TODO during 7s scan of relationship-service repo, print cool status about dirs being scanned

# usageMsg is intentionally placed at the very top for human readers and future agents.
# It must start on the second line of the script, right below the shebang.
# usageMsg formatting and content ALWAYS trumps showUsage. If you change usageMsg,
# you MUST update showUsage to match it EXACTLY, including newlines and spacing.
# Agents must not update usageMsg without explicit instructions to do so.
# When they aren't in sync, agents must update showUsage's underlying
# non-colorized text to match usageMsg, while keeping all colorization intact.

set -e # Exit on error

# Global default ignore folder names (repeatable via --ignore). Placed globally so helper
# functions can access it (bash local scoping does not create closures).
ignoreNames=("2delete")

main() {
    local autoConfirm=0
    local depth=2
    local verbose=0
    local dryRun=0
    local normalizeDirs=()
    local pruneDuration=""
    local repoRoot
    local inGitRepo=0
    local archiveDir="aidocs"
    local noTimestamp=0
    local noCamelCase=0
    local ignoreOverridden=0
    local normalizeOverridden=0
    local longFormat=0
    local interactive=0

    # Print to terminal a colorized version of the usage message.
    # IMPORTANT: usageMsg formatting ALWAYS trumps showUsage. If you change usageMsg, you MUST update showUsage to match it EXACTLY, including newlines and spacing. Do NOT change showUsage formatting independently.
    showUsage() {
        local RESET=$'\033[0m'
        local BOLD=$'\033[1m'
        local UNDERLINE=$'\033[4m'
        local ITALIC=$'\033[3m'
        # Use standard ANSI colors for broader terminal compatibility
        local CMD_COLOR=$'\033[1;34m'     # bright blue
        local FLAG_COLOR=$'\033[1;36m'    # bright cyan
        local FS_VAR_COLOR=$'\033[32m'    # green
        local FS_LIT_COLOR=$'\033[1;32m'  # bright green
        local ARG_VAR_COLOR=$'\033[33m'   # yellow
        local ARG_LIT_COLOR=$'\033[1;33m' # bright yellow
        local YES_COLOR=$'\033[1;31m'     # bright red
        echo -e "${BOLD}${UNDERLINE}NAME${RESET}"
        echo -e "    ${CMD_COLOR}mdar${RESET} - Archive untracked markdown files as ${FS_LIT_COLOR}${UNDERLINE}aidocs/${RESET}${FS_VAR_COLOR}${UNDERLINE}${ITALIC}YYYY-MM-DD/hhmm_CamelCase${RESET}${FS_LIT_COLOR}${UNDERLINE}.md${RESET}"
        echo
        echo -e "${BOLD}${UNDERLINE}SYNOPSIS${RESET}"
        echo -e "    ${CMD_COLOR}mdar${RESET} [${FLAG_COLOR}--archive${RESET} ${FS_VAR_COLOR}${UNDERLINE}${ITALIC}DIR${RESET}] [${FLAG_COLOR}--normalize${RESET} ${FS_VAR_COLOR}${UNDERLINE}${ITALIC}DIR${RESET}] [${FLAG_COLOR}--ignore${RESET} ${FS_VAR_COLOR}${UNDERLINE}${ITALIC}DIR${RESET}] [${FLAG_COLOR}--depth${RESET} ${ARG_VAR_COLOR}${ITALIC}N${RESET}] [${FLAG_COLOR}-r${RESET}|${FLAG_COLOR}--recursive${RESET}]"
        echo -e "        [${FLAG_COLOR}--no-timestamp${RESET}] [${FLAG_COLOR}--no-camelcase${RESET}] [${FLAG_COLOR}--prune${RESET} ${ARG_VAR_COLOR}${ITALIC}N<mhdwMy>${RESET}]"
        echo -e "        [${FLAG_COLOR}-n${RESET}|${FLAG_COLOR}--dry-run${RESET}] [${YES_COLOR}-y${RESET}|${YES_COLOR}--yes${RESET}] [${FLAG_COLOR}-i${RESET}|${FLAG_COLOR}--interactive${RESET}] [${FLAG_COLOR}-l${RESET}|${FLAG_COLOR}--long${RESET}] [${FLAG_COLOR}-v${RESET}|${FLAG_COLOR}-vv${RESET}|${FLAG_COLOR}-vvv${RESET}] [${FLAG_COLOR}-x${RESET}]"
        echo
        echo -e "${BOLD}${UNDERLINE}DESCRIPTION${RESET}"
        echo -e "    Archive untracked markdown files into dated folders, by default normalized to"
        echo -e "    ${FS_LIT_COLOR}${UNDERLINE}aidocs/${RESET}${FS_VAR_COLOR}${UNDERLINE}${ITALIC}YYYY-MM-DD/hhmm_CamelCasedVersionOfOriginalName${RESET}${FS_LIT_COLOR}${UNDERLINE}.md${RESET}."
        echo -e "    This cleans up AI-generated docs, sorting them temporally in IDE folder viewers."
        echo -e "    Files inside ${FS_VAR_COLOR}${UNDERLINE}${ITALIC}YYYY-MM-DD/HHMM/${RESET} directories are exempt from filename normalization"
        echo -e "    (useful to cluster fraternal-sibling files)."
        echo -e "    Files inside ${FS_VAR_COLOR}${UNDERLINE}${ITALIC}YYYY-MM-DD/${RESET} directories are kept in place, and if they have"
        echo -e "    a ${FS_VAR_COLOR}${UNDERLINE}${ITALIC}HHMM${RESET} prefix it is preserved."
        echo
        echo -e "    Ignore patterns can be specified via ${FLAG_COLOR}--ignore${RESET} flag or in ${FS_LIT_COLOR}${UNDERLINE}mdar_ignore${RESET} file (one"
        echo -e "    pattern per line, ${FS_VAR_COLOR}#${RESET} for comments). Patterns match directory names and filenames."
        echo
        echo -e "${BOLD}${UNDERLINE}OPTIONS${RESET}"
        echo -e "    ${FLAG_COLOR}--archive${RESET} ${FS_VAR_COLOR}${UNDERLINE}${ITALIC}DIR${RESET}       Archive to this directory (default: ${FS_LIT_COLOR}${UNDERLINE}aidocs/${RESET})"
        echo -e "    ${FLAG_COLOR}--normalize${RESET} ${FS_VAR_COLOR}${UNDERLINE}${ITALIC}DIR${RESET}     Normalize ${FS_VAR_COLOR}${UNDERLINE}${ITALIC}DIR${RESET} in-place    (default: ${FS_LIT_COLOR}${UNDERLINE}test-results/${RESET}, repeatable)"
        echo -e "    ${FLAG_COLOR}--ignore${RESET} ${FS_VAR_COLOR}${UNDERLINE}${ITALIC}PATTERN${RESET}    Ignore dirs/files matching ${FS_VAR_COLOR}${UNDERLINE}${ITALIC}PATTERN${RESET} (default: ${FS_LIT_COLOR}${UNDERLINE}2delete/${RESET}, repeatable)"
        echo -e "                        Also reads patterns from ${FS_LIT_COLOR}${UNDERLINE}mdar_ignore${RESET} (one per line, ${FS_VAR_COLOR}#${RESET} comments)"
        echo -e "    ${FLAG_COLOR}--depth${RESET} ${ARG_VAR_COLOR}${ITALIC}N${RESET}           Directory depth to search (default: ${ARG_LIT_COLOR}2${RESET}, root only: ${ARG_LIT_COLOR}0${RESET})"
        echo -e "    ${FLAG_COLOR}-r${RESET}, ${FLAG_COLOR}--recursive${RESET}     Search all subdirectories recursively (depth=${ARG_VAR_COLOR}∞${RESET})"
        echo -e "    ${FLAG_COLOR}--no-timestamp${RESET}      Do not normalize filenames by adding ${ARG_VAR_COLOR}${ITALIC}hhmm${RESET} create-time prefix"
        echo -e "    ${FLAG_COLOR}--no-camelcase${RESET}      Do not normalize filenames by changing to ${FS_VAR_COLOR}${UNDERLINE}${ITALIC}CamelCase${RESET}"
        echo -e "    ${FLAG_COLOR}--prune${RESET} ${ARG_VAR_COLOR}${ITALIC}N<mhdwMy>${RESET}   Delete target files older than e.g., ${ARG_LIT_COLOR}30d${RESET}, ${ARG_LIT_COLOR}4w${RESET}, ${ARG_LIT_COLOR}1M${RESET}"
        echo -e "    ${FLAG_COLOR}-n${RESET}, ${FLAG_COLOR}--dry-run${RESET}       Show proposed ${CMD_COLOR}mv${RESET}/${CMD_COLOR}rm${RESET} operations and exit (no prompt, no changes)"
        echo -e "    ${YES_COLOR}-y${RESET}, ${YES_COLOR}--yes${RESET}           Skip confirmation prompt, execute ${CMD_COLOR}mv${RESET}/${CMD_COLOR}rm${RESET} operations immediately"
        echo -e "    ${FLAG_COLOR}-i${RESET}, ${FLAG_COLOR}--interactive${RESET}   Prompt for confirmation on each individual operation"
        echo -e "    ${FLAG_COLOR}-l${RESET}, ${FLAG_COLOR}--long${RESET}          Show birthtime and modtime columns in output (long format)"
        echo -e "    ${FLAG_COLOR}-v${RESET}, ${FLAG_COLOR}-vv${RESET}, ${FLAG_COLOR}-vvv${RESET}       Logging level: 1: what, 2: +how (${CMD_COLOR}find${RESET}/${CMD_COLOR}git${RESET}/${CMD_COLOR}mv${RESET}/${CMD_COLOR}rm${RESET}), 3: +debug"
        echo -e "    ${FLAG_COLOR}-x${RESET}                  Enable shell tracing (${CMD_COLOR}set -x${RESET})"
        echo
        echo -e "${BOLD}${UNDERLINE}EXAMPLE OUTPUT${RESET}"
        echo -e "  ${FS_LIT_COLOR}${UNDERLINE}HTTP_RESPONSE_COMPATIBILITY.md${RESET}            →  ${FS_LIT_COLOR}${UNDERLINE}aidocs/2025-11-22/1520_HTTPResponseCompatibility.md${RESET}"
        echo -e "  ${FS_LIT_COLOR}${UNDERLINE}test-results/HTTP_200_vs_400.md${RESET}           →  ${FS_LIT_COLOR}${UNDERLINE}test-results/2025-11-22_1530_HTTP200Vs400.md${RESET}"
        echo -e "  ${FS_LIT_COLOR}${UNDERLINE}aidocs/2015-11-01/request_signing_fix.md${RESET}  →  [DELETE]"
    }

    # vlog: logging utility (define before any calls so it's available during option parsing and early runtime checks)
    # Log levels:
    # 1: What's happening (high-level context, file counts, operation summaries)
    # 2: How it's happening (command execution, operation attempts)
    # 3: Debug trace (function parameters, filtering decisions, data transformations)
    #
    # Note: This script typically runs in under a second, so we bypass the logging best
    # practice of timestamping each log line. Timestamps would add clutter without value.
    vlog() {
        local level="$1"; shift
        if [ "$verbose" -ge "$level" ]; then
            local msg="$*"
            if [[ -z "${msg//[[:space:]]/}" ]]; then
                return
            fi
            while IFS= read -r line || [ -n "$line" ]; do
                [[ -z "${line//[[:space:]]/}" ]] && continue
                echo "+ $line" >&2
            done <<< "$msg"
        fi
    }

    # Manual option parsing for macOS compatibility (BSD getopt doesn't support long options)
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --archive)
                archiveDir="$2"; shift 2 ;;
            --ignore)
                if [ -z "$2" ]; then
                    echo "--ignore requires a non-empty pattern" >&2
                    showUsage >&2
                    exit 1
                fi
                if [ $ignoreOverridden -eq 0 ]; then
                    ignoreNames=()   # override default on first user-provided --ignore
                    ignoreOverridden=1
                fi
                ignoreNames+=("$2")
                shift 2 ;;
            --no-timestamp)
                noTimestamp=1; shift ;;
            --no-camelcase)
                noCamelCase=1; shift ;;
            -n|--dry-run)
                dryRun=1; shift ;;
            -y|--yes)
                autoConfirm=1; shift ;;
            -i|--interactive)
                interactive=1; shift ;;
            -l|--long)
                longFormat=1; shift ;;
            -r|--recursive)
                depth=-1; shift ;;
            --depth)
                depth="$2"; shift 2 ;;
            --normalize)
                if [ $normalizeOverridden -eq 0 ]; then
                    normalizeDirs=()   # override default on first user-provided --normalize
                    normalizeOverridden=1
                fi
                normalizeDirs+=("$2"); shift 2 ;;
            --prune)
                pruneDuration="$2"; shift 2 ;;
            -v)
                verbose=$((verbose+1)); shift ;;
            -vv)
                verbose=$((verbose+2)); shift ;;
            -vvv)
                verbose=$((verbose+3)); shift ;;
            -vvvv)
                verbose=$((verbose+4)); shift ;;
            --verbose)
                verbose=$((verbose+1)); shift ;;
            -x)
                set -x; shift ;;
            -h|--help)
                showUsage; exit 0 ;;
            -H|--raw-help)
                printf "%s" "$usageMsg"; exit 0 ;;
            --)
                shift; break ;;
            -*)
                echo "Unknown option: $1" >&2
                showUsage >&2
                exit 1 ;;
            *)
                break ;;
        esac
    done

    # Load additional ignore patterns from mdar_ignore if it exists in the same directory as this script
    local scriptDir
    scriptDir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
    local mdarignoreFile="${scriptDir}/mdar_ignore"
    if [ -f "$mdarignoreFile" ]; then
        vlog 2 "Loading ignore patterns from ${mdarignoreFile}"
        while IFS= read -r line; do
            # Skip empty lines and comments (lines starting with #)
            [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
            # Trim leading/trailing whitespace
            line=$(echo "$line" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
            [ -n "$line" ] && ignoreNames+=("$line")
        done < "$mdarignoreFile"
        vlog 2 "Loaded $(grep -v '^[[:space:]]*#' "$mdarignoreFile" | grep -v '^[[:space:]]*$' | wc -l | tr -d ' ') patterns from ${mdarignoreFile}"
    fi

    # Always work in current directory, but check if it's part of a git repo
    # for determining whether to use git commands to find untracked files
    repoRoot=$(pwd)
    vlog 2 "To find out if we are in a git repo, running: git rev-parse --git-dir"
    if git rev-parse --git-dir > /dev/null 2>&1; then
        inGitRepo=1
    else
        inGitRepo=0
    fi

    shouldIgnorePath() {
        local p="$1"
        local filename
        filename=$(basename "$p")
        for igRaw in "${ignoreNames[@]}"; do
            [ -z "$igRaw" ] && continue
            local ig="${igRaw%/}"
            vlog 3 "Checking ignore pattern: $ig against path: $p and filename: $filename"
            if [[ "$p" == "$ig"* ]] || [[ "$p" == */"$ig"/* ]] || [[ "$p" == */"$ig" ]]; then
                vlog 3 "Ignoring path: $p (matches pattern: $ig)"
                return 0
            fi
            if [[ "$filename" == "$ig" ]]; then
                vlog 3 "Ignoring path: $p (filename matches: $ig)"
                return 0
            fi
        done
        vlog 3 "Path not ignored: $p"
        return 1
    }

    normalizePaths() {
        vlog 3 "normalizePaths: Strip leading './' and drop empty lines"
        local in="$1"
        vlog 3 "Input to normalizePaths: $in"
        echo "$in" | sed -e 's|^\./||' -e 's|^$||' | grep -v '^$' || true
    }

    findUntrackedMarkdown() {
        vlog 3 "findUntrackedMarkdown: repoRoot=$1, depth=$2, inGitRepo=$3"
        local repoRoot="$1"
        local depth="$2"
        local inGitRepo="$3"
        local files=""
        if [ "$inGitRepo" -eq 1 ]; then
            vlog 1 "In git repo: $repoRoot"
            vlog 2 "To find untracked markdown, running: git status --porcelain, git ls-files"
            statusFiles=$(git --no-pager -C "$repoRoot" status --porcelain | grep '^?? ' | sed 's/^?? //' || true)
            lsFiles=$(git --no-pager -C "$repoRoot" ls-files --others --exclude-standard || true)
            vlog 3 "Combining statusFiles and lsFiles, sorting, deduping, filtering for .md files"
            files=$(printf "%s\n%s\n" "$statusFiles" "$lsFiles" | sort | uniq | grep -v '^$' | grep '\.md$' | grep -v '^aidocs/')
            if [ "${#ignoreNames[@]}" -gt 0 ]; then
                vlog 3 "Applying ignore filters to markdown files"
                files=$(echo "$files" | while IFS= read -r f; do [ -z "$f" ] && continue; if ! shouldIgnorePath "$f"; then echo "$f"; fi; done)
            fi
            if [ "$depth" -ge 0 ]; then
                vlog 3 "Filtering markdown files by depth: $depth"
                files=$(echo "$files" | awk -F'/' -v depth="$depth" 'NF <= depth + 1')
            fi
        else
            vlog 1 "Not in a git repo. Searching for markdown files in: $repoRoot"
            if [ "$depth" -eq -1 ]; then
                vlog 2 "Running: find . -type f -name '*.md' (recursive)"
                files=$(cd "$repoRoot" && find . -type f -name '*.md' 2>/dev/null | sed 's|^./||' | grep -v '^aidocs/')
            else
                vlog 2 "Running: find . -maxdepth $((depth + 1)) -type f -name '*.md'"
                files=$(cd "$repoRoot" && find . -maxdepth $((depth + 1)) -type f -name '*.md' 2>/dev/null | sed 's|^./||' | grep -v '^aidocs/')
            fi
            if [ "${#ignoreNames[@]}" -gt 0 ]; then
                vlog 3 "Applying ignore filters to markdown files"
                files=$(echo "$files" | while IFS= read -r f; do [ -z "$f" ] && continue; if ! shouldIgnorePath "$f"; then echo "$f"; fi; done)
            fi
        fi
        vlog 2 "Untracked markdown files found: $(echo "$files" | wc -l | tr -d ' ')"
        echo "$files"
    }

    extractTimestamp() {
        vlog 3 "extractTimestamp: filename=$1"
        local filename="$1"
        local date="" time=""
        vlog 3 "BASH_REMATCH: [0]=full match, [1]=first capture group, [2]=second capture group, etc."
        if [[ "$filename" =~ ([0-9]{4}-[0-9]{2}-[0-9]{2})_([0-9]{6}) ]]; then
            date="${BASH_REMATCH[1]}"; time="${BASH_REMATCH[2]:0:4}"
        # Regex: Matches YYYY-MM-DD_hhmm
        elif [[ "$filename" =~ ([0-9]{4}-[0-9]{2}-[0-9]{2})_([0-9]{4}) ]]; then
            date="${BASH_REMATCH[1]}"; time="${BASH_REMATCH[2]}"
        # Regex: Matches YYYYMMDD_hhmmSS
        elif [[ "$filename" =~ ([0-9]{8})_([0-9]{6}) ]]; then
            date="${BASH_REMATCH[1]:0:4}-${BASH_REMATCH[1]:4:2}-${BASH_REMATCH[1]:6:2}"; time="${BASH_REMATCH[2]:0:4}"
        # Regex: Matches YYYYMMDD_hhmm
        elif [[ "$filename" =~ ([0-9]{8})_([0-9]{4}) ]]; then
            date="${BASH_REMATCH[1]:0:4}-${BASH_REMATCH[1]:4:2}-${BASH_REMATCH[1]:6:2}"; time="${BASH_REMATCH[2]}"
        # Regex: Matches YYYYMMDD-hhmmSS
        elif [[ "$filename" =~ ([0-9]{4})([0-9]{2})([0-9]{2})-([0-9]{2})([0-9]{2})([0-9]{2}) ]]; then
            date="${BASH_REMATCH[1]}-${BASH_REMATCH[2]}-${BASH_REMATCH[3]}"; time="${BASH_REMATCH[4]}${BASH_REMATCH[5]}"
        # Regex: Matches YYYYMMDDhhmmSS
        elif [[ "$filename" =~ ([0-9]{4})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2}) ]]; then
            date="${BASH_REMATCH[1]}-${BASH_REMATCH[2]}-${BASH_REMATCH[3]}"; time="${BASH_REMATCH[4]}${BASH_REMATCH[5]}"
        # Regex: Matches YYYY-MM-DD-hhmmSS
        elif [[ "$filename" =~ ([0-9]{4})-([0-9]{2})-([0-9]{2})-([0-9]{2})([0-9]{2})([0-9]{2}) ]]; then
            date="${BASH_REMATCH[1]}-${BASH_REMATCH[2]}-${BASH_REMATCH[3]}"; time="${BASH_REMATCH[4]}${BASH_REMATCH[5]}"
        # Regex: Matches YYYY-MM-DD
        elif [[ "$filename" =~ ([0-9]{4})-([0-9]{2})-([0-9]{2}) ]]; then
            date="${BASH_REMATCH[1]}-${BASH_REMATCH[2]}-${BASH_REMATCH[3]}"; time="0000"
        # Regex: Matches YYYYMMDD
        elif [[ "$filename" =~ ([0-9]{4})([0-9]{2})([0-9]{2}) ]]; then
            date="${BASH_REMATCH[1]}-${BASH_REMATCH[2]}-${BASH_REMATCH[3]}"; time="0000"
        fi
        echo "$date|$time"
    }

    toCamelCase() {
        vlog 3 "toCamelCase: filename=$1"
        local filename="$1"
        local base="${filename%.*}"
        vlog 3 "Stripping timestamp patterns before CamelCase conversion"
        # Strip YYYY-MM-DD[_hhmm...] style timestamps
        base=$(echo "$base" | sed -E 's/[_-]?[0-9]{4}-[0-9]{2}-[0-9]{2}(_[0-9]{4,6})?[_-]?//g')
        # Strip YYYYMMDD-hhmmss style timestamps
        base=$(echo "$base" | sed -E 's/[_-]?[0-9]{8}-[0-9]{6}[_-]?//g')
        # Strip compact YYYYMMDDhhmmss timestamps
        base=$(echo "$base" | sed -E 's/[_-]?[0-9]{14}[_-]?//g')
        # Strip compact YYYYMMDD timestamps
        base=$(echo "$base" | sed -E 's/[_-]?[0-9]{8}[_-]?//g')
        # Strip standalone hhmm_ time prefix (e.g. 1210_FileName)
        base=$(echo "$base" | sed -E 's/^[0-9]{4}_//')
        if [[ ! "$base" =~ [_-] ]]; then
            if [[ "$base" =~ ^[A-Z0-9]+$ ]]; then
                vlog 3 "Token is ALL CAPS/alphanumeric - converting to Title case (e.g. FOO -> Foo)"
                echo "$(echo "$base" | awk '{print toupper(substr($0,1,1)) tolower(substr($0,2))}')"
            else
                vlog 3 "Mixed/lowercase token - preserving casing, ensuring uppercase first char"
                echo "$(echo "${base:0:1}" | tr '[:lower:]' '[:upper:]')${base:1}"
            fi
            return
        fi
        vlog 3 "Multiple parts separated by '_' or '-' - converting to CamelCase"
        echo "$base" | sed -e 's/[_-]/ /g' | awk '{for(i=1;i<=NF;i++){$i=toupper(substr($i,1,1)) tolower(substr($i,2))}}1' | sed 's/ //g'
    }

    parseDurationToSeconds() {
        vlog 3 "parseDurationToSeconds: duration=$1"
        local duration="$1"
        local num="${duration%[mhdwMy]}"
        local unit="${duration#$num}"
        [ -z "$unit" ] && unit="d"
        case "$unit" in
            m) echo $((num * 60)) ;;
            h) echo $((num * 3600)) ;;
            d) echo $((num * 86400)) ;;
            w) echo $((num * 7 * 86400)) ;;
            M) echo $((num * 30 * 86400)) ;;
            y) echo $((num * 365 * 86400)) ;;
            *) echo "Invalid duration unit: $unit" >&2; return 1 ;;
        esac
    }

    collectPruneOps() {
        vlog 3 "collectPruneOps: find files in normalizeDirs=(${normalizeDirs[*]}) older than cutoff"
        local repoRoot="$1" duration="$2" archiveDir="$3"
        shift 3
        local normalizeDirs=("$@")
        # Calculate cutoffTime: now - duration (in seconds)
        local now durationSeconds cutoffTime
        now=$(date +%s)
        durationSeconds=$(parseDurationToSeconds "$duration")
        cutoffTime=$((now - durationSeconds))
        vlog 3 "Cutoff time: $cutoffTime ($(date -r "$cutoffTime" '+%Y-%m-%d %H:%M:%S'))"
        local pruneOps=()
        # Search all normalize dirs (which already includes archiveDir and test-results)
        # Deduplicate directories manually (for bash 3.2 compatibility on macOS)
        local dirsToSearch=()
        for dir in "${normalizeDirs[@]}"; do
            local found=0
            for existing in "${dirsToSearch[@]}"; do
                if [ "$dir" = "$existing" ]; then
                    found=1
                    break
                fi
            done
            [ "$found" -eq 0 ] && dirsToSearch+=("$dir")
        done
        for searchDir in "${dirsToSearch[@]}"; do
            [ ! -d "$repoRoot/$searchDir" ] && continue
            vlog 3 "Using NUL-delimited find in $searchDir to handle special filenames"
            while IFS= read -r -d '' f; do
                f="${f#./}"
                [ "$f" = "${archiveDir}/README.md" ] && continue
                if shouldIgnorePath "$f"; then
                    continue
                fi
                local mtime
                mtime=$(stat -f "%m" "$repoRoot/$f" 2>/dev/null || echo 0)
                [ "$mtime" -lt "$cutoffTime" ] && pruneOps+=("$f")
            done < <(cd "$repoRoot" && find "$searchDir" -type f -print0 2>/dev/null)
        done
        # Print one operation per line for the caller to read safely
        printf '%s\n' "${pruneOps[@]}"
    }

    collectNormalizeOps() {
        vlog 3 "collectNormalizeOps: repoRoot=$1 archiveDir=$2 dirs=$(printf '%s ' "${dirs[@]}")"
        local repoRoot="$1"
        local archiveDir="$2"
        local dirs=("${@:3}")
        local normalizeOps=()
        for dir in "${dirs[@]}"; do
            [ ! -d "$repoRoot/$dir" ] && continue
            vlog 3 "Using NUL-delimited find in $dir to handle special filenames"
            while IFS= read -r -d '' filepath; do
                filepath="${filepath#./}"
                [ -z "$filepath" ] && continue
                if shouldIgnorePath "$filepath"; then
                    continue
                fi
                local dirname filename base extension
                dirname=$(dirname "$filepath")
                filename=$(basename "$filepath")
                base="${filename%.*}"
                extension="${filename##*.}"
                [ "$extension" = "$filename" ] && extension=""
                # Check if file is inside YYYY-MM-DD/HHMM/ directory (exempt from normalization)
                local parentDirName grandparentDirName greatGrandparentDir
                parentDirName=$(basename "$dirname")
                local parentPath
                parentPath=$(dirname "$dirname")
                grandparentDirName=$(basename "$parentPath")
                greatGrandparentDir=$(dirname "$parentPath")
                if [[ "$parentDirName" =~ ^[0-9]{4}$ ]] && [[ "$grandparentDirName" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]]; then
                    vlog 3 "Skipping file in YYYY-MM-DD/HHMM/ directory: $filepath"
                    continue
                fi
                vlog 3 "Using birth time for normalization (ignoring any extracted timestamp)"
                local btime mtime date time
                btime=$(stat -f "%B" "$repoRoot/$filepath" 2>/dev/null || echo 0)
                mtime=$(stat -f "%m" "$repoRoot/$filepath" 2>/dev/null || echo 0)
                date=$(date -r "${btime:-$mtime}" '+%Y-%m-%d' 2>/dev/null || echo "unknown")
                time=$(date -r "${btime:-$mtime}" '+%H%M' 2>/dev/null || echo "0000")
                local camelCaseName
                camelCaseName=$(toCamelCase "$base")
                local newFilename newPath newDirname
                # ::: Code Generated by Copilot :::
                # Check if parent directory name contains a date (YYYY-MM-DD pattern)
                local parentDirName
                parentDirName=$(basename "$dirname")
                local parentHasDate=0
                if [[ "$parentDirName" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]]; then
                    parentHasDate=1
                fi
                # Check if we're in a dated subdirectory of archiveDir
                local grandparentDir
                grandparentDir=$(dirname "$dirname")
                newDirname="$dirname"
                if [ "$dirname" = "$archiveDir" ]; then
                    # File is directly in archiveDir root - move to dated subfolder
                    newDirname="$archiveDir/$date"
                elif [ "$parentHasDate" -eq 1 ] && [ "$grandparentDir" = "$archiveDir" ]; then
                    # File is in archiveDir/YYYY-MM-DD/ - trust the folder date, keep in place
                    # Check if file already has HHMM prefix - if so, it's compliant
                    if [[ "$filename" =~ ^[0-9]{4}_ ]]; then
                        vlog 3 "File in dated directory with HHMM prefix, skipping: $filepath"
                        continue
                    fi
                    # File needs HHMM prefix but stays in this folder
                    newDirname="$dirname"
                fi
                # Determine if the NEW directory has a date pattern (to decide on filename format)
                local newParentDirName
                newParentDirName=$(basename "$newDirname")
                local omitDatePrefix=0
                if [[ "$newParentDirName" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]]; then
                    omitDatePrefix=1
                fi
                if [ -n "$extension" ]; then
                    if [ "$noTimestamp" -eq 1 ]; then
                        newFilename="${camelCaseName}.${extension}"
                    elif [ "$omitDatePrefix" -eq 1 ]; then
                        newFilename="${time}_${camelCaseName}.${extension}"
                    else
                        newFilename="${date}_${time}_${camelCaseName}.${extension}"
                    fi
                else
                    if [ "$noTimestamp" -eq 1 ]; then
                        newFilename="${camelCaseName}"
                    elif [ "$omitDatePrefix" -eq 1 ]; then
                        newFilename="${time}_${camelCaseName}"
                    else
                        newFilename="${date}_${time}_${camelCaseName}"
                    fi
                fi
                newPath="${newDirname}/${newFilename}"
                # Compliance: filename matches normalized pattern AND timestamp matches birth time
                # AND (for dated directories) the directory date matches the file's birth date
                # Pattern 1: yyyy-mm-dd_hhmm_CamelCase.ext (files in non-dated folders)
                # Pattern 2: hhmm_CamelCase.ext (files in dated folders like 2025-11-19/)
                local compliantPattern1='^[0-9]{4}-[0-9]{2}-[0-9]{2}_[0-9]{4}_[A-Z][A-Za-z0-9]*(\.[^.]+)?$'
                local compliantPattern2='^[0-9]{4}_[A-Z][A-Za-z0-9]*(\.[^.]+)?$'
                local isCompliant=0
                # Determine which pattern should apply based on directory structure
                local expectedPattern=""
                if [ "$parentHasDate" -eq 1 ] && [ "$grandparentDir" = "$archiveDir" ]; then
                    # File is in a dated subdirectory of archiveDir - should use pattern 2 (time only)
                    expectedPattern="$compliantPattern2"
                else
                    # File is not in a dated archiveDir subdirectory - should use pattern 1 (date_time)
                    expectedPattern="$compliantPattern1"
                fi
                if [[ "$filename" =~ $expectedPattern ]]; then
                    # Check if timestamp in filename matches actual birth time
                    local btime mtime actualTime
                    btime=$(stat -f "%B" "$repoRoot/$filepath" 2>/dev/null || echo 0)
                    mtime=$(stat -f "%m" "$repoRoot/$filepath" 2>/dev/null || echo 0)
                    actualTime=$(date -r "${btime:-$mtime}" '+%H%M' 2>/dev/null || echo "0000")
                    local filenameTime=""
                    if [[ "$filename" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}_([0-9]{4})_ ]]; then
                        filenameTime="${BASH_REMATCH[1]}"
                    elif [[ "$filename" =~ ^([0-9]{4})_ ]]; then
                        filenameTime="${BASH_REMATCH[1]}"
                    fi
                    # File is compliant if pattern matches AND timestamp matches actual birth time
                    # AND (for files in dated dirs) the directory date matches the file's birth date
                    if [ "$filenameTime" = "$actualTime" ]; then
                        # Check if file is in a dated subdirectory of archiveDir
                        if [ "$parentHasDate" -eq 1 ] && [ "$grandparentDir" = "$archiveDir" ]; then
                            # Verify the directory date matches the file's actual date
                            if [ "$parentDirName" = "$date" ]; then
                                isCompliant=1
                            fi
                        else
                            # Not in a dated archiveDir subdirectory, so just check filename
                            isCompliant=1
                        fi
                    fi
                fi
                if [ "$isCompliant" -eq 0 ] && [ "$filepath" != "$newPath" ]; then
                    normalizeOps+=("$filepath|$newPath|$btime|$mtime")
                fi
            done < <(cd "$repoRoot" && find "$dir" -type f -print0 2>/dev/null)
        done
        # Print one operation per line for the caller to read safely
        printf '%s\n' "${normalizeOps[@]}"
    }

    # Main logic
    # Add default normalize directories if user hasn't overridden with --normalize
    if [ $normalizeOverridden -eq 0 ]; then
        normalizeDirs=("$archiveDir" "test-results")
    else
        # Always include archiveDir in normalization even if user specified custom dirs
        normalizeDirs=("$archiveDir" "${normalizeDirs[@]}")
    fi
    vlog 1 "Options parsed: dryRun=$dryRun autoConfirm=$autoConfirm depth=$depth normalizeDirs=(${normalizeDirs[*]}) pruneDuration=$pruneDuration archiveDir=$archiveDir noTimestamp=$noTimestamp noCamelCase=$noCamelCase ignoreNames=(${ignoreNames[*]}) ignoreOverridden=$ignoreOverridden normalizeOverridden=$normalizeOverridden"
    vlog 2 "Active ignore folder names: ${ignoreNames[*]}"
    local markdownFiles
    markdownFiles=$(findUntrackedMarkdown "$repoRoot" "$depth" "$inGitRepo")
    markdownFiles=$(normalizePaths "$markdownFiles")
    count=$(echo "$markdownFiles" | grep -c '^')
    vlog 1 "Discovered $count untracked markdown files in $repoRoot"
    vlog 3 "$markdownFiles"
    if [ -z "$markdownFiles" ]; then
        vlog 1 "No markdown files found, skipping untrackedOps loop."
    else
        local untrackedOps=()
        vlog 2 "Mapping $count markdown files to archive destinations in $archiveDir"
        while IFS= read -r file; do
            [ -z "$file" ] && continue
            if shouldIgnorePath "$file"; then
                continue
            fi
            local base ext
            base=$(basename "$file")
            ext="${base##*.}"
            local ts date time
            ts=$(extractTimestamp "$base")
            date="${ts%%|*}"; time="${ts##*|}"
            if [ -z "$date" ]; then
                local btime mtime
                btime=$(stat -f "%B" "$file" 2>/dev/null || echo 0)
                mtime=$(stat -f "%m" "$file" 2>/dev/null || echo 0)
                date=$(date -r "${btime:-$mtime}" '+%Y-%m-%d' 2>/dev/null || echo "unknown")
                time=$(date -r "${btime:-$mtime}" '+%H%M' 2>/dev/null || echo "0000")
            fi
            local namePart
            if [ "$noCamelCase" -eq 1 ]; then
                namePart="${base%.*}"
            else
                namePart=$(toCamelCase "${base%.*}")
            fi
            local dest
            if [ "$noTimestamp" -eq 1 ]; then
                dest="$archiveDir/$namePart.$ext"
            else
                dest="$archiveDir/$date/${time}_${namePart}.$ext"
            fi
            untrackedOps+=("$file|$dest|$btime|$mtime")
        done <<< "$markdownFiles"
    fi

    vlog 3 "NOTE: Using while loop instead of mapfile (not available in macOS default bash)"
    normalizeOps=()
    while IFS= read -r line; do
        [ -n "$line" ] && normalizeOps+=("$line")
    done < <(collectNormalizeOps "$repoRoot" "$archiveDir" "${normalizeDirs[@]}")
    pruneOps=()
    if [ -n "$pruneDuration" ]; then
        while IFS= read -r line; do
            [ -n "$line" ] && pruneOps+=("$line")
        done < <(collectPruneOps "$repoRoot" "$pruneDuration" "$archiveDir" "${normalizeDirs[@]}")
    fi

    # Remove from normalizeOps any files that are in pruneOps (pruning takes precedence)
    if [ ${#pruneOps[@]} -gt 0 ]; then
        local filteredNormalizeOps=()
        for op in "${normalizeOps[@]}"; do
            local src="${op%%|*}"
            local shouldSkip=0
            for pruneFile in "${pruneOps[@]}"; do
                if [ "$src" = "$pruneFile" ]; then
                    shouldSkip=1
                    break
                fi
            done
            [ "$shouldSkip" -eq 0 ] && filteredNormalizeOps+=("$op")
        done
        normalizeOps=("${filteredNormalizeOps[@]}")
    fi

    local totalOps=$(( ${#untrackedOps[@]} + ${#normalizeOps[@]} + ${#pruneOps[@]} ))
    vlog 1 "Total operations: $totalOps (normalize=${#normalizeOps[@]}, untracked=${#untrackedOps[@]}, prune=${#pruneOps[@]})"
    [ "$totalOps" -eq 0 ] && echo "Executed 0 of 0 proposed operations" >&2 && exit 0

    vlog 3 "Calculating max source path length for output formatting"
    local maxLen=0
    for op in "${untrackedOps[@]}" "${normalizeOps[@]}"; do
        local src="${op%%|*}"
        [ ${#src} -gt $maxLen ] && maxLen=${#src}
    done
    for file in "${pruneOps[@]}"; do
        [ ${#file} -gt $maxLen ] && maxLen=${#file}
    done

    # Helper function to format timestamp for display
    formatTimestamp() {
        local ts="$1"
        [ "$ts" = "0" ] && echo "unknown" && return
        date -r "$ts" '+%Y-%m-%d %H:%M' 2>/dev/null || echo "unknown"
    }

    vlog 3 "Combining and sorting operations by destination path"
    local allOps=()
    for op in "${normalizeOps[@]}" "${untrackedOps[@]}"; do
        allOps+=("$op")
    done
    # Sort allOps by destination path (second field)
    local sortedOps=()
    while IFS= read -r line; do
        [ -n "$line" ] && sortedOps+=("$line")
    done < <(printf '%s\n' "${allOps[@]}" | sort -t'|' -k2,2)
    
    # Print sorted normalization and untracked operations (skip in interactive mode since each op is shown individually)
    if [ "${interactive:-0}" -eq 0 ]; then
        if [ "$longFormat" -eq 1 ]; then
            # Print header for long format
            printf "  %-${maxLen}s  %-16s  %-16s  %s\n" "Source" "Birth" "Mod" "Destination"
            printf "  %-${maxLen}s  %-16s  %-16s  %s\n" "$(printf '%*s' "$maxLen" '' | tr ' ' '-')" "----------------" "----------------" "$(printf '%s' "---" | tr ' ' '-')"
        fi

        for op in "${sortedOps[@]}"; do
            IFS='|' read -r src dst btime mtime <<< "$op"
            if [ "$longFormat" -eq 1 ]; then
                local birthStr modStr
                birthStr=$(formatTimestamp "$btime")
                modStr=$(formatTimestamp "$mtime")
                printf "  %-${maxLen}s  %-16s  %-16s  →  %s\n" "$src" "$birthStr" "$modStr" "$dst"
            else
                printf "  %-${maxLen}s  →  %s\n" "$src" "$dst"
            fi
        done

        # Print prune operations at the end
        for file in "${pruneOps[@]}"; do
            if [ "$longFormat" -eq 1 ]; then
                # Get timestamps for prune operations
                local btime mtime birthStr modStr
                btime=$(stat -f "%B" "$file" 2>/dev/null || echo 0)
                mtime=$(stat -f "%m" "$file" 2>/dev/null || echo 0)
                birthStr=$(formatTimestamp "$btime")
                modStr=$(formatTimestamp "$mtime")
                printf "  %-${maxLen}s  %-16s  %-16s  →  [DELETE]\n" "$file" "$birthStr" "$modStr"
            else
                printf "  %-${maxLen}s  →  [DELETE]\n" "$file"
            fi
        done
    fi

    if [ "${dryRun:-0}" -eq 1 ]; then
        vlog 1 "Dry-run mode: exiting without executing operations"
        echo "Dry-run: Executed 0 of $totalOps proposed operations" >&2
        exit 0
    fi

    if [ "${interactive:-0}" -eq 0 ] && [ "${autoConfirm:-0}" -eq 0 ]; then
        # Prompt for single-character confirmation (y/Y to proceed)
        read -p "Proceed with these operations? [y/N] " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            vlog 1 "Operation cancelled by user"
            echo "Cancelled." >&2
            echo "Executed 0 of $totalOps proposed operations" >&2
            exit 0
        fi
    fi

    vlog 1 "Executing $totalOps operations"

    local executedOps=0
    local skippedOps=0
    for op in "${normalizeOps[@]}"; do
        IFS='|' read -r src dst btime mtime <<< "$op"
        local destDir
        destDir=$(dirname "$dst")

        if [ -f "$dst" ]; then
            vlog 2 "Skipping $src: destination $dst already exists"
            printf "  ⚠ %-${maxLen}s  (destination exists)\n" "$src"
            continue
        fi

        # Interactive mode: prompt for each operation
        if [ "${interactive:-0}" -eq 1 ]; then
            printf "\nmv \"%s\" \"%s\"\n" "$src" "$dst"
            read -p "Execute this move? [y/N] " -n 1 -r
            echo
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                printf "  ⊘ %-${maxLen}s  (skipped)\n" "$src"
                skippedOps=$((skippedOps+1))
                continue
            fi
        fi

        mkdir -p "$destDir"
        if mv "$src" "$dst"; then
            executedOps=$((executedOps+1))
            printf "  ✓ %-${maxLen}s  →  %s\n" "$src" "$dst"
        else
            vlog 2 "Failed to move $src to $dst"
            printf "  ⚠ %-${maxLen}s  (failed to move)\n" "$src" >&2
        fi
    done
    for op in "${untrackedOps[@]}"; do
        IFS='|' read -r src dst btime mtime <<< "$op"
        local destDir
        destDir=$(dirname "$dst")

        if [ -f "$dst" ]; then
            vlog 2 "Skipping $src: destination $dst already exists"
            printf "  ⚠ %-${maxLen}s  (destination exists)\n" "$src"
            continue
        fi

        # Interactive mode: prompt for each operation
        if [ "${interactive:-0}" -eq 1 ]; then
            printf "\nmv \"%s\" \"%s\"\n" "$src" "$dst"
            read -p "Execute this move? [y/N] " -n 1 -r
            echo
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                printf "  ⊘ %-${maxLen}s  (skipped)\n" "$src"
                skippedOps=$((skippedOps+1))
                continue
            fi
        fi

        mkdir -p "$destDir"
        if mv "$src" "$dst"; then
            executedOps=$((executedOps+1))
            printf "  ✓ %-${maxLen}s  →  %s\n" "$src" "$dst"
        else
            vlog 2 "Failed to move $src to $dst"
            printf "  ⚠ %-${maxLen}s  (failed to move)\n" "$src" >&2
        fi
    done
    for file in "${pruneOps[@]}"; do
        # Interactive mode: prompt for each delete operation
        if [ "${interactive:-0}" -eq 1 ]; then
            printf "\nrm \"%s\"\n" "$file"
            read -p "Execute this delete? [y/N] " -n 1 -r
            echo
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                printf "  ⊘ %-${maxLen}s  (skipped)\n" "$file"
                skippedOps=$((skippedOps+1))
                continue
            fi
        fi

        if [ -f "$file" ] && rm "$file"; then
            executedOps=$((executedOps+1))
            printf "  ✓ %-${maxLen}s  →  [DELETED]\n" "$file"
        else
            vlog 2 "Failed to delete $file"
            printf "  ⚠ %-${maxLen}s  (failed to delete)\n" "$file" >&2
        fi
    done
    if [ "${interactive:-0}" -eq 1 ]; then
        echo "Executed $executedOps of $totalOps proposed operations (skipped $skippedOps)" >&2
    else
        echo "Executed $executedOps of $totalOps proposed operations" >&2
    fi
}

main "$@"
