#!/bin/bash
usageMsg="\
NAME
    mdar - Archive untracked markdown files as aidocs/YYYY-MM-DD/hhmm_CamelCase.md

SYNOPSIS
    mdar [--archive DIR] [--no-timestamp] [--no-camelcase] [-y|--yes]
         [-r|--recursive] [--depth N] [--normalize DIR] [--prune N<mhdwMy>]
         [-v|-vv|-vvv] [-x] [-n|--dry-run]

DESCRIPTION
    Archive untracked markdown files into dated folders, by default normalized to
    aidocs/YYYY-MM-DD/hhmm_CamelCasedVersionOfOriginalName.md.
    This cleans up AI-generated docs, sorting them in IDE folder viewers.

OPTIONS
    --archive DIR       Archive directory (default: aidocs/)
    --no-timestamp      Do not normalize filenames with hhmm create-time prefix
    --no-camelcase      Do not normalize filenames to CamelCase
    -n, --dry-run       Show proposed mv operations and exit (no prompt, no changes)
    -y, --yes           Skip confirmation prompt, execute mv operations immediately
    -v, -vv, -vvv       Verbosity: -v=find/mv files, -vv=+debug, -vvv=+shell tracing
    -x                  Enable shell tracing (set -x)
    -r, --recursive     Search all subdirectories recursively (depth=∞)
    --depth N           Directory depth to search (0=root only, default: 2)
    --normalize DIR     Normalize DIR in-place (default: test-results/, can be repeated)
    --prune N<mhdwMy>   Delete target files older than e.g., 30d, 4w, 1M
"

# usageMsg is intentionally placed at the very top for human readers and future agents.
# It must start on the second line of the script, right below the shebang.
# usageMsg formatting and content ALWAYS trumps showUsage. If you change usageMsg,
# you MUST update showUsage to match it EXACTLY, including newlines and spacing.
# Agents must not update usageMsg without explicit instructions to do so.
# When they aren't in sync, agents must update showUsage's underlying
# non-colorized text to match usageMsg, while keeping all colorization intact.

set -e # Exit on error

main() {
    local autoConfirm=0
    local depth=2
    local verbose=0
    local dryRun=0
    local normalizeDirs=()
    local pruneDuration=""
    local repoRoot
    local inGitRepo=0
    local archiveDir="aidocs"
    local noTimestamp=0
    local noCamelCase=0

    # Print to terminal a colorized version of the usage message.
    # IMPORTANT: usageMsg formatting ALWAYS trumps showUsage. If you change usageMsg, you MUST update showUsage to match it EXACTLY, including newlines and spacing. Do NOT change showUsage formatting independently.
    showUsage() {
        local CMD_COLOR=$'\033[1;94m'
        local OPTION_COLOR=$'\033[1;92m'
        local ARGVAL_COLOR=$'\033[1;38;5;208m'
        local DEFAULT_COLOR=$'\033[1;95m'
        local EMPHASIS_COLOR=$'\033[1;94m'
        local RESET=$'\033[0m'
        local BOLD=$'\033[1m'
        local UNDERLINE=$'\033[4m'
        local FS_COLOR=$'\033[1;94m' # Blue for filesystem entities
        local MAGENTA_COLOR=$'\033[1;95m' # Magenta for argument values only
        local YES_COLOR=$'\033[1;91m'      # Brightest red for -y/--yes

        printf "%b%bNAME%b\n" "$BOLD" "$UNDERLINE" "$RESET"
        printf "    %bmdar%b - Archive untracked markdown files as %baidocs/YYYY-MM-DD/hhmm_CamelCase.md%b\n" "$CMD_COLOR" "$RESET" "$FS_COLOR" "$RESET"
        printf "\n"
        printf "%b%bSYNOPSIS%b\n" "$BOLD" "$UNDERLINE" "$RESET"
        printf "    %bmdar%b [%b--archive%b %bDIR%b] [%b--no-timestamp%b] [%b--no-camelcase%b] [%b-y%b|%b--yes%b]\n" "$FS_COLOR" "$RESET" "$OPTION_COLOR" "$RESET" "$FS_COLOR" "$RESET" "$OPTION_COLOR" "$RESET" "$OPTION_COLOR" "$RESET" "$YES_COLOR" "$RESET" "$YES_COLOR" "$RESET"
        printf "         [%b-r%b|%b--recursive%b] [%b--depth%b %bN%b] [%b--normalize%b %bDIR%b] [%b--prune%b %bN<mhdwMy>%b]\n" "$OPTION_COLOR" "$RESET" "$OPTION_COLOR" "$RESET" "$OPTION_COLOR" "$RESET" "$MAGENTA_COLOR" "$RESET" "$OPTION_COLOR" "$RESET" "$FS_COLOR" "$RESET" "$OPTION_COLOR" "$RESET" "$MAGENTA_COLOR" "$RESET"
        printf "         [%b-v%b|%b-vv%b|%b-vvv%b] [%b-x%b] [%b-n%b|%b--dry-run%b]\n\n" "$OPTION_COLOR" "$RESET" "$OPTION_COLOR" "$RESET" "$OPTION_COLOR" "$RESET" "$OPTION_COLOR" "$RESET" "$OPTION_COLOR" "$RESET" "$OPTION_COLOR" "$RESET"
        printf "%b%bDESCRIPTION%b\n" "$BOLD" "$UNDERLINE" "$RESET"
        printf "    Archive untracked markdown files into dated folders, by default normalized to\n"
        printf "    %baidocs/YYYY-MM-DD/hhmm_CamelCasedVersionOfOriginalName.md.%b\n" "$FS_COLOR" "$RESET"
        printf "    This cleans up AI-generated docs, sorting them in IDE folder viewers.\n\n"
        printf "%b%bOPTIONS%b\n" "$BOLD" "$UNDERLINE" "$RESET"
        printf "    %b--archive%b %bDIR%b       Archive directory (default: %baidocs/%b)\n" "$OPTION_COLOR" "$RESET" "$FS_COLOR" "$RESET" "$FS_COLOR" "$RESET"
        printf "    %b--no-timestamp%b      Do not normalize filenames with %bhhmm%b create-time prefix\n" "$OPTION_COLOR" "$RESET" "$FS_COLOR" "$RESET"
        printf "    %b--no-camelcase%b      Do not normalize filenames to %bCamelCase%b\n" "$OPTION_COLOR" "$RESET" "$FS_COLOR" "$RESET"
        printf "    %b-n%b, %b--dry-run%b       Show proposed %bmv%b operations and exit (no prompt, no changes)\n" "$OPTION_COLOR" "$RESET" "$OPTION_COLOR" "$RESET" "$FS_COLOR" "$RESET"
        printf "    %b-y%b, %b--yes%b           %bSkip confirmation prompt, execute%b %bmv%b %boperations immediately%b\n" \
            "$YES_COLOR" "$RESET" \
            "$YES_COLOR" "$RESET" \
            "$YES_COLOR" "$RESET" \
            "$FS_COLOR" "$RESET" \
            "$YES_COLOR" "$RESET"
        printf "    %b-v%b, %b-vv%b, %b-vvv%b       Verbosity: %b-v%b=%bfind/mv%b files, %b-vv%b=+debug, %b-vvv%b=+shell tracing\n" "$OPTION_COLOR" "$RESET" "$OPTION_COLOR" "$RESET" "$OPTION_COLOR" "$RESET" "$OPTION_COLOR" "$RESET" "$FS_COLOR" "$RESET" "$OPTION_COLOR" "$RESET" "$OPTION_COLOR" "$RESET"
        printf "    %b-x%b                  Enable shell tracing (%bset -x%b)\n" "$OPTION_COLOR" "$RESET" "$CMD_COLOR" "$RESET"
        printf "    %b-r%b, %b--recursive%b     Search all subdirectories recursively (depth=%b∞%b)\n" "$OPTION_COLOR" "$RESET" "$OPTION_COLOR" "$RESET" "$MAGENTA_COLOR" "$RESET"
        printf "    %b--depth%b %bN%b           Directory depth to search (%b0%b=root only, default: %b2%b)\n" "$OPTION_COLOR" "$RESET" "$MAGENTA_COLOR" "$RESET" "$MAGENTA_COLOR" "$RESET" "$MAGENTA_COLOR" "$RESET"
        printf "    %b--normalize%b %bDIR%b     Normalize %bDIR%b in-place (default: %btest-results/%b, can be repeated)\n" "$OPTION_COLOR" "$RESET" "$FS_COLOR" "$RESET" "$FS_COLOR" "$RESET" "$FS_COLOR" "$RESET"
        printf "    %b--prune%b %bN<mhdwMy>%b   Delete target files older than e.g., %b30d%b, %b4w%b, %b1M%b\n" \
            "$OPTION_COLOR" "$RESET" \
            "$MAGENTA_COLOR" "$RESET" \
            "$MAGENTA_COLOR" "$RESET" \
            "$MAGENTA_COLOR" "$RESET" \
            "$MAGENTA_COLOR" "$RESET"
    }

    # Manual option parsing for macOS compatibility (BSD getopt doesn't support long options)
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --archive)
                archiveDir="$2"; shift 2 ;;
            --no-timestamp)
                noTimestamp=1; shift ;;
            --no-camelcase)
                noCamelCase=1; shift ;;
            -n|--dry-run)
                dryRun=1; shift ;;
            -y|--yes)
                autoConfirm=1; shift ;;
            -r|--recursive)
                depth=-1; shift ;;
            --depth)
                depth="$2"; shift 2 ;;
            --normalize)
                normalizeDirs+=("$2"); shift 2 ;;
            --prune)
                pruneDuration="$2"; shift 2 ;;
            -v|--verbose)
                verbose=$((verbose+1)); shift ;;
            -x)
                set -x; shift ;;
            -h|--help)
                showUsage; exit 0 ;;
            -H|--raw-help)
                printf "%s" "$usageMsg"; exit 0 ;;
            --)
                shift; break ;;
            -*)
                echo "Unknown option: $1" >&2
                showUsage >&2
                exit 1 ;;
            *)
                break ;;
        esac
    done

    if git rev-parse --git-dir > /dev/null 2>&1; then
        inGitRepo=1
        repoRoot=$(git rev-parse --show-toplevel)
    else
        repoRoot=$(pwd)
    fi
    cd "$repoRoot"

    # Helper to print verbose commands to stderr
    verboseLog() {
        local level="$1"; shift
        if [ "$verbose" -ge "$level" ]; then
            echo "+ $*" >&2
        fi
    }

    # Normalize paths: ensure entries are relative to repoRoot and not prefixed with './'
    normalizePaths() {
        local in="$1"
        echo "$in" | sed -e 's|^\./||' -e 's|^$||' | grep -v '^$' || true
    }

    # Find untracked markdown files based on depth setting
    findUntrackedMarkdown() {
        local repoRoot="$1"
        local depth="$2"
        local inGitRepo="$3"
        local files=""
        if [ "$inGitRepo" -eq 1 ]; then
            local statusFiles lsFiles
            statusFiles=$(git --no-pager -C "$repoRoot" status --porcelain | grep '^?? ' | sed 's/^?? //' || true)
            lsFiles=$(git --no-pager -C "$repoRoot" ls-files --others --exclude-standard || true)
            files=$(printf "%s\n%s\n" "$statusFiles" "$lsFiles" | sort | uniq | grep -v '^$' | grep '\.md$' | grep -v '^aidocs/')
            if [ "$depth" -ge 0 ]; then
                files=$(echo "$files" | awk -F'/' -v depth="$depth" 'NF <= depth + 1')
            fi
        else
            if [ "$depth" -eq -1 ]; then
                files=$(cd "$repoRoot" && find . -type f -name '*.md' 2>/dev/null | sed 's|^./||' | grep -v '^aidocs/')
            else
                files=$(cd "$repoRoot" && find . -maxdepth $((depth + 1)) -type f -name '*.md' 2>/dev/null | sed 's|^./||' | grep -v '^aidocs/')
            fi
        fi
        echo "$files"
    }

    # Extract timestamp from filename
    extractTimestamp() {
        local filename="$1"
        local date="" time=""
        # BASH_REMATCH is a bash array containing the full match and capture groups from the last successful regex match in [[ ... =~ ... ]].
        # BASH_REMATCH[0] is the full match, BASH_REMATCH[1] is the first capture group, BASH_REMATCH[2] is the second, etc.
        # Regex: Matches YYYY-MM-DD_hhmmSS or YYYY-MM-DD_hhmm
        if [[ "$filename" =~ ([0-9]{4}-[0-9]{2}-[0-9]{2})_([0-9]{6}) ]]; then
            date="${BASH_REMATCH[1]}"; time="${BASH_REMATCH[2]:0:4}"
        # Regex: Matches YYYY-MM-DD_hhmm
        elif [[ "$filename" =~ ([0-9]{4}-[0-9]{2}-[0-9]{2})_([0-9]{4}) ]]; then
            date="${BASH_REMATCH[1]}"; time="${BASH_REMATCH[2]}"
        # Regex: Matches YYYYMMDD_hhmmSS
        elif [[ "$filename" =~ ([0-9]{8})_([0-9]{6}) ]]; then
            date="${BASH_REMATCH[1]:0:4}-${BASH_REMATCH[1]:4:2}-${BASH_REMATCH[1]:6:2}"; time="${BASH_REMATCH[2]:0:4}"
        # Regex: Matches YYYYMMDD_hhmm
        elif [[ "$filename" =~ ([0-9]{8})_([0-9]{4}) ]]; then
            date="${BASH_REMATCH[1]:0:4}-${BASH_REMATCH[1]:4:2}-${BASH_REMATCH[1]:6:2}"; time="${BASH_REMATCH[2]}"
        # Regex: Matches YYYYMMDD-hhmmSS
        elif [[ "$filename" =~ ([0-9]{4})([0-9]{2})([0-9]{2})-([0-9]{2})([0-9]{2})([0-9]{2}) ]]; then
            date="${BASH_REMATCH[1]}-${BASH_REMATCH[2]}-${BASH_REMATCH[3]}"; time="${BASH_REMATCH[4]}${BASH_REMATCH[5]}"
        # Regex: Matches YYYYMMDDhhmmSS
        elif [[ "$filename" =~ ([0-9]{4})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2}) ]]; then
            date="${BASH_REMATCH[1]}-${BASH_REMATCH[2]}-${BASH_REMATCH[3]}"; time="${BASH_REMATCH[4]}${BASH_REMATCH[5]}"
        # Regex: Matches YYYY-MM-DD-hhmmSS
        elif [[ "$filename" =~ ([0-9]{4})-([0-9]{2})-([0-9]{2})-([0-9]{2})([0-9]{2})([0-9]{2}) ]]; then
            date="${BASH_REMATCH[1]}-${BASH_REMATCH[2]}-${BASH_REMATCH[3]}"; time="${BASH_REMATCH[4]}${BASH_REMATCH[5]}"
        # Regex: Matches YYYY-MM-DD
        elif [[ "$filename" =~ ([0-9]{4})-([0-9]{2})-([0-9]{2}) ]]; then
            date="${BASH_REMATCH[1]}-${BASH_REMATCH[2]}-${BASH_REMATCH[3]}"; time="0000"
        # Regex: Matches YYYYMMDD
        elif [[ "$filename" =~ ([0-9]{4})([0-9]{2})([0-9]{2}) ]]; then
            date="${BASH_REMATCH[1]}-${BASH_REMATCH[2]}-${BASH_REMATCH[3]}"; time="0000"
        fi
        echo "$date|$time"
    }

    # Convert filename to CamelCase, stripping timestamps
    toCamelCase() {
        local filename="$1"
        local base="${filename%.*}"
        base=$(echo "$base" | sed -E 's/[_-]?[0-9]{4}-[0-9]{2}-[0-9]{2}(_[0-9]{4,6})?[_-]?//g')
        base=$(echo "$base" | sed -E 's/[_-]?[0-9]{8}-[0-9]{6}[_-]?//g')
        base=$(echo "$base" | sed -E 's/[_-]?[0-9]{14}[_-]?//g')
        base=$(echo "$base" | sed -E 's/[_-]?[0-9]{8}[_-]?//g')
        if [[ ! "$base" =~ [_-] ]]; then
            if [[ "$base" =~ ^[A-Z0-9]+$ ]]; then
                echo "$(echo "$base" | awk '{print toupper(substr($0,1,1)) tolower(substr($0,2))}')"
            else
                echo "$(echo "${base:0:1}" | tr '[:lower:]' '[:upper:]')${base:1}"
            fi
            return
        fi
        echo "$base" | sed -e 's/[_-]/ /g' | awk '{for(i=1;i<=NF;i++){$i=toupper(substr($i,1,1)) tolower(substr($i,2))}}1' | sed 's/ //g'
    }

    # Parse duration string to seconds
    parseDurationToSeconds() {
        local duration="$1"
        local num="${duration%[mhdwMy]}"
        local unit="${duration#$num}"
        [ -z "$unit" ] && unit="d"
        case "$unit" in
            m) echo $((num * 60)) ;;
            h) echo $((num * 3600)) ;;
            d) echo $((num * 86400)) ;;
            w) echo $((num * 7 * 86400)) ;;
            M) echo $((num * 30 * 86400)) ;;
            y) echo $((num * 365 * 86400)) ;;
            *) echo "Invalid duration unit: $unit" >&2; return 1 ;;
        esac
    }

    # Collect files to prune
    collectPruneOps() {
        local repoRoot="$1" duration="$2" archiveDir="$3"
        local cutoffTime
        cutoffTime=$(($(date +%s) - $(parseDurationToSeconds "$duration")))
        local files
        # Find all files in the archive directory, excluding README.md
        files=$(cd "$repoRoot" && find "$archiveDir" -type f 2>/dev/null | sed 's|^./||' | grep -v "^${archiveDir}/README.md$" || true)
        local pruneOps=()
        for f in $files; do
            local mtime
            mtime=$(stat -f "%m" "$repoRoot/$f" 2>/dev/null || echo 0)
            [ "$mtime" -lt "$cutoffTime" ] && pruneOps+=("$f")
        done
        echo "${pruneOps[@]}"
    }

    # Collect files to normalize in specified directories
    collectNormalizeOps() {
        local repoRoot="$1"
        local dirs=("${@:2}")
        local normalizeOps=()
        for dir in "${dirs[@]}"; do
            [ ! -d "$repoRoot/$dir" ] && continue
            local files
            files=$(cd "$repoRoot" && find "$dir" -type f 2>/dev/null | sed 's|^./||' || true)
            for filepath in $files; do
                [ -z "$filepath" ] && continue
                local dirname filename base extension
                dirname=$(dirname "$filepath")
                filename=$(basename "$filepath")
                base="${filename%.*}"
                extension="${filename##*.}"
                [ "$extension" = "$filename" ] && extension=""
                # Extract timestamp
                local ts date time
                ts=$(extractTimestamp "$base")
                date="${ts%%|*}"; time="${ts##*|}"
                [ -z "$date" ] && date="$(date -r "$(stat -f '%m' "$repoRoot/$filepath" 2>/dev/null || echo 0)" '+%Y-%m-%d' 2>/dev/null || echo 'unknown')"
                [ -z "$time" ] && time="$(date -r "$(stat -f '%m' "$repoRoot/$filepath" 2>/dev/null || echo 0)" '+%H%M' 2>/dev/null || echo '0000')"
                local camelCaseName
                camelCaseName=$(toCamelCase "$base")
                local newFilename newPath
                if [ -n "$extension" ]; then
                    newFilename="${date}_${time}_${camelCaseName}.${extension}"
                else
                    newFilename="${date}_${time}_${camelCaseName}"
                fi
                newPath="${dirname}/${newFilename}"
                # Compliance: filename matches normalized pattern (yyyy-mm-dd_hhmm_CamelCase.ext)
                # Regex: Matches filenames like 2025-11-22_1234_MyFile.md or 2025-11-22_1234_MyFile.txt
                local compliantPattern='^[0-9]{4}-[0-9]{2}-[0-9]{2}_[0-9]{4}_[A-Z][A-Za-z0-9]*(\.[^.]+)?$' # yyyy-mm-dd_hhmm_CamelCase.ext
                if [[ ! "$filename" =~ $compliantPattern ]] && [ "$filepath" != "$newPath" ]; then
                    normalizeOps+=("$filepath|$newPath")
                fi
            done
        done
        echo "${normalizeOps[@]}"
    }

    # Main logic
    verboseLog 1 "Options parsed: dryRun=$dryRun autoConfirm=$autoConfirm depth=$depth normalizeDirs=(${normalizeDirs[*]}) pruneDuration=$pruneDuration archiveDir=$archiveDir noTimestamp=$noTimestamp noCamelCase=$noCamelCase"
    verboseLog 1 "Searching for untracked markdown files..."
    local markdownFiles
    markdownFiles=$(findUntrackedMarkdown "$repoRoot" "$depth" "$inGitRepo")
    verboseLog 1 "Found markdown files: $markdownFiles"
    markdownFiles=$(normalizePaths "$markdownFiles")
    verboseLog 1 "Normalized markdown file paths: $markdownFiles"

    if [ -z "$markdownFiles" ]; then
        verboseLog 1 "No markdown files found, skipping untrackedOps loop."
    else
        local untrackedOps=()
        verboseLog 1 "Building untrackedOps array..."
        while IFS= read -r file; do
            [ -z "$file" ] && continue
            local base ext
            base=$(basename "$file")
            ext="${base##*.}"
            local ts date time
            ts=$(extractTimestamp "$base")
            date="${ts%%|*}"; time="${ts##*|}"
            if [ -z "$date" ]; then
                local btime mtime
                btime=$(stat -f "%B" "$file" 2>/dev/null || echo 0)
                mtime=$(stat -f "%m" "$file" 2>/dev/null || echo 0)
                date=$(date -r "${btime:-$mtime}" '+%Y-%m-%d' 2>/dev/null || echo "unknown")
                time=$(date -r "${btime:-$mtime}" '+%H%M' 2>/dev/null || echo "0000")
            fi
            local namePart
            if [ "$noCamelCase" -eq 1 ]; then
                namePart="${base%.*}"
            else
                namePart=$(toCamelCase "${base%.*}")
            fi
            local dest
            if [ "$noTimestamp" -eq 1 ]; then
                dest="$archiveDir/$namePart.$ext"
            else
                dest="$archiveDir/$date/${time}_${namePart}.$ext"
            fi
            untrackedOps+=("$file|$dest")
        done <<< "$markdownFiles"
        verboseLog 1 "Built untrackedOps: ${untrackedOps[*]}"
    fi

    # NOTE: mapfile is NOT available in macOS's default /bin/bash. Use a portable alternative below.
    # Instead of: mapfile -t normalizeOps < <(collectNormalizeOps ...)
    # Use:
    normalizeOps=()
    while IFS= read -r line; do
        [ -n "$line" ] && normalizeOps+=("$line")
    done < <(collectNormalizeOps "$repoRoot" "${normalizeDirs[@]}")
    # Instead of: mapfile -t pruneOps < <(collectPruneOps ...)
    pruneOps=()
    if [ -n "$pruneDuration" ]; then
        while IFS= read -r line; do
            [ -n "$line" ] && pruneOps+=("$line")
        done < <(collectPruneOps "$repoRoot" "$pruneDuration" "$archiveDir")
    fi

    local totalOps=$(( ${#untrackedOps[@]} + ${#normalizeOps[@]} + ${#pruneOps[@]} ))
    [ "$totalOps" -eq 0 ] && echo "Executed 0 of 0 proposed operations" >&2 && exit 0

    local maxLen=0
    for op in "${untrackedOps[@]}" "${normalizeOps[@]}"; do
        local src="${op%%|*}"
        [ ${#src} -gt $maxLen ] && maxLen=${#src}
    done
    for file in "${pruneOps[@]}"; do
        [ ${#file} -gt $maxLen ] && maxLen=${#file}
    done

    # Display normalization operations first if present
    if [ ${#normalizeOps[@]} -gt 0 ]; then
        for op in "${normalizeOps[@]}"; do
            local src="${op%%|*}" dst="${op##*|}"
            printf "  %-${maxLen}s  →  %s\n" "$src" "$dst"
        done
    fi
    for op in "${untrackedOps[@]}"; do
        local src="${op%%|*}" dst="${op##*|}"
        printf "  %-${maxLen}s  →  %s\n" "$src" "$dst"
    done
    for file in "${pruneOps[@]}"; do
        printf "  %-${maxLen}s  →  [DELETE]\n" "$file"
    done

    # If dry-run was requested, never prompt: print summary and exit immediately.
    if [ "${dryRun:-0}" -eq 1 ]; then
        echo "Dry-run: Executed 0 of $totalOps proposed operations" >&2
        exit 0
    fi

    # If autoConfirm was not set, ask the user. Note: dry-run already returned above.
    if [ "${autoConfirm:-0}" -eq 0 ]; then
        # Prompt for single-character confirmation (y/Y to proceed)
        read -p "Proceed with these operations? [y/N] " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            echo "Cancelled." >&2
            echo "Executed 0 of $totalOps proposed operations" >&2
            exit 0
        fi
    fi

    local executedOps=0
    for op in "${normalizeOps[@]}"; do
        local src="${op%%|*}" dst="${op##*|}"
        local destDir
        destDir=$(dirname "$dst")
        mkdir -p "$destDir"
        if [ -f "$dst" ]; then
            printf "  ⚠ %-${maxLen}s  (destination exists)\n" "$src"
            continue
        fi
        if mv "$src" "$dst"; then
            executedOps=$((executedOps+1))
            printf "  ✓ %-${maxLen}s  →  %s\n" "$src" "$dst"
        else
            printf "  ⚠ %-${maxLen}s  (failed to move)\n" "$src" >&2
        fi
    done
    for op in "${untrackedOps[@]}"; do
        local src="${op%%|*}" dst="${op##*|}"
        local destDir
        destDir=$(dirname "$dst")
        mkdir -p "$destDir"
        if [ -f "$dst" ]; then
            printf "  ⚠ %-${maxLen}s  (destination exists)\n" "$src"
            continue
        fi
        if mv "$src" "$dst"; then
            executedOps=$((executedOps+1))
            printf "  ✓ %-${maxLen}s  →  %s\n" "$src" "$dst"
        else
            printf "  ⚠ %-${maxLen}s  (failed to move)\n" "$src" >&2
        fi
    done
    for file in "${pruneOps[@]}"; do
        if [ -f "$file" ] && rm "$file"; then
            executedOps=$((executedOps+1))
            printf "  ✓ %-${maxLen}s  →  [DELETED]\n" "$file"
        else
            printf "  ⚠ %-${maxLen}s  (failed to delete)\n" "$file" >&2
        fi
    done
    echo "Executed $executedOps of $totalOps proposed operations" >&2
}

main "$@"
