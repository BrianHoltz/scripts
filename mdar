#!/bin/bash

# mdar - Archive untracked markdown files into well-known locations with uniform naming
# Purpose: Archive ntracked ephemeral markdown files created by AI agents
#          using hierarchical datetime'd names that sort temporally even
#          when viewed in an IDE file tree with no sorting functionality.
#
# Actions:
#   - Move untracked markdown → aidocs/YYYY-MM-DD/HHMM_CamelCase.md
#   - By default, depth=2 and so will fix any misnamed files under aidocs/
#   - Normalizes filenames in-place in specified folders (by default: test-results/)
#   - Reuses timestamps in filenames when present (e.g., 20251114-135621)
#   - Reports proposed renames/moves, but NEVER PERFORMS THEM without -y or terminal confirmation
#
# Options:
#   -n, --dry-run       Show proposed operations and exit (no prompt, no changes)
#   -y, --yes           Skip confirmation prompt and execute immediately
#   -v, -vv, -vvv       Increase verbosity: -v=key commands, -vv=+debug info, -vvv=+shell tracing
#   -x                  Enable shell tracing (set -x)
#   -r, --recursive     Search all subdirectories recursively (unlimited depth)
#   --depth N           Directory depth to search (0=root only, 1=root+immediate subdirs, default: 2)
#   --normalize DIR     Normalize files in DIR in-place (can be repeated, default: test-results)
#   --prune DURATION    Delete aidocs files older than DURATION (e.g., 14d, 2w, 3m, 1y)
#
# Usage: mdar [-y|--yes] [-r|--recursive] [--depth N] [--normalize DIR] [--prune DURATION] [-v|-vv|-vvv] [-x] [-n|--dry-run]

set -e

main() {
    local autoConfirm=0
    local depth=2
    local verbose=0
    local traceMode=0
    local dryRun=0
    local normalizeDirs=()
    local normalizeExplicit=0
    local pruneDuration=""
    local repoRoot
    local inGitRepo=0

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -y|--yes)
                autoConfirm=1; shift ;;
            -r|--recursive)
                depth=-1; shift ;;
            --depth)
                if [[ -n "$2" && "$2" =~ ^[0-9]+$ ]]; then
                    depth="$2"; shift 2
                else
                    echo "Error: --depth requires a non-negative integer" >&2; exit 1
                fi ;;
            --normalize)
                if [[ -n "$2" && ! "$2" =~ ^- ]]; then
                    normalizeDirs+=("$2"); normalizeExplicit=1; shift 2
                else
                    echo "Error: --normalize requires a directory argument" >&2; exit 1
                fi ;;
            --prune)
                if [[ -n "$2" && "$2" =~ ^[0-9]+[dwmy]?$ ]]; then
                    pruneDuration="$2"; shift 2
                else
                    echo "Error: --prune requires a duration (e.g., 14d, 2w, 3m, 1y)" >&2; exit 1
                fi ;;
            -v*)
                local opt="$1"
                verbose=$(echo "$opt" | tr -cd 'v' | wc -c | tr -d ' ')
                if [ "$verbose" -ge 3 ]; then traceMode=1; verbose=2; fi
                shift ;;
            --verbose)
                verbose=1; shift ;;
            -x)
                traceMode=1; shift ;;
            -n|--dry-run)
                dryRun=1; shift ;;
            *)
                echo "Unknown option: $1" >&2
                echo "Usage: mdar [-y|--yes] [-r|--recursive] [--depth N] [--normalize DIR] [--prune DURATION] [-v|-vv|-vvv] [-x] [-n|--dry-run]" >&2
                exit 1 ;;
        esac
    done

    [ "$traceMode" -eq 1 ] && set -x

    # Check if in git repo
    if git rev-parse --git-dir > /dev/null 2>&1; then
        inGitRepo=1
        repoRoot=$(git rev-parse --show-toplevel)
    else
        repoRoot=$(pwd)
    fi
    cd "$repoRoot"

    # Helper to print verbose commands to stderr
    verboseLog() {
        local level="$1"; shift
        if [ "$verbose" -ge "$level" ]; then
            echo "+ $*" >&2
        fi
    }

    # Normalize paths: ensure entries are relative to repoRoot and not prefixed with './'
    normalizePaths() {
        local in="$1"
        echo "$in" | sed -e 's|^\./||' -e 's|^$||' | grep -v '^$' || true
    }

    # Find untracked markdown files based on depth setting
    findUntrackedMarkdown() {
        local repoRoot="$1"
        local depth="$2"
        local inGitRepo="$3"
        local files=""
        if [ "$inGitRepo" -eq 1 ]; then
            local statusFiles lsFiles
            statusFiles=$(git --no-pager -C "$repoRoot" status --porcelain | grep '^?? ' | sed 's/^?? //' || true)
            lsFiles=$(git --no-pager -C "$repoRoot" ls-files --others --exclude-standard || true)
            files=$(printf "%s\n%s\n" "$statusFiles" "$lsFiles" | sort | uniq | grep -v '^$' | grep '\.md$' | grep -v '^aidocs/')
            if [ "$depth" -ge 0 ]; then
                files=$(echo "$files" | awk -F'/' -v depth="$depth" 'NF <= depth + 1')
            fi
        else
            if [ "$depth" -eq -1 ]; then
                files=$(cd "$repoRoot" && find . -type f -name '*.md' 2>/dev/null | sed 's|^./||' | grep -v '^aidocs/')
            else
                files=$(cd "$repoRoot" && find . -maxdepth $((depth + 1)) -type f -name '*.md' 2>/dev/null | sed 's|^./||' | grep -v '^aidocs/')
            fi
        fi
        echo "$files"
    }

    # Extract timestamp from filename
    extractTimestamp() {
        local filename="$1"
        local date="" time=""
        if [[ "$filename" =~ ([0-9]{4}-[0-9]{2}-[0-9]{2})_([0-9]{6}) ]]; then
            date="${BASH_REMATCH[1]}"; time="${BASH_REMATCH[2]:0:4}"
        elif [[ "$filename" =~ ([0-9]{4}-[0-9]{2}-[0-9]{2})_([0-9]{4}) ]]; then
            date="${BASH_REMATCH[1]}"; time="${BASH_REMATCH[2]}"
        elif [[ "$filename" =~ ([0-9]{8})_([0-9]{6}) ]]; then
            date="${BASH_REMATCH[1]:0:4}-${BASH_REMATCH[1]:4:2}-${BASH_REMATCH[1]:6:2}"; time="${BASH_REMATCH[2]:0:4}"
        elif [[ "$filename" =~ ([0-9]{8})_([0-9]{4}) ]]; then
            date="${BASH_REMATCH[1]:0:4}-${BASH_REMATCH[1]:4:2}-${BASH_REMATCH[1]:6:2}"; time="${BASH_REMATCH[2]}"
        elif [[ "$filename" =~ ([0-9]{4})([0-9]{2})([0-9]{2})-([0-9]{2})([0-9]{2})([0-9]{2}) ]]; then
            date="${BASH_REMATCH[1]}-${BASH_REMATCH[2]}-${BASH_REMATCH[3]}"; time="${BASH_REMATCH[4]}${BASH_REMATCH[5]}"
        elif [[ "$filename" =~ ([0-9]{4})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2}) ]]; then
            date="${BASH_REMATCH[1]}-${BASH_REMATCH[2]}-${BASH_REMATCH[3]}"; time="${BASH_REMATCH[4]}${BASH_REMATCH[5]}"
        elif [[ "$filename" =~ ([0-9]{4})-([0-9]{2})-([0-9]{2})-([0-9]{2})([0-9]{2})([0-9]{2}) ]]; then
            date="${BASH_REMATCH[1]}-${BASH_REMATCH[2]}-${BASH_REMATCH[3]}"; time="${BASH_REMATCH[4]}${BASH_REMATCH[5]}"
        elif [[ "$filename" =~ ([0-9]{4})-([0-9]{2})-([0-9]{2}) ]]; then
            date="${BASH_REMATCH[1]}-${BASH_REMATCH[2]}-${BASH_REMATCH[3]}"; time="0000"
        elif [[ "$filename" =~ ([0-9]{4})([0-9]{2})([0-9]{2}) ]]; then
            date="${BASH_REMATCH[1]}-${BASH_REMATCH[2]}-${BASH_REMATCH[3]}"; time="0000"
        fi
        echo "$date|$time"
    }

    # Convert filename to CamelCase, stripping timestamps
    toCamelCase() {
        local filename="$1"
        local base="${filename%.*}"
        base=$(echo "$base" | sed -E 's/[_-]?[0-9]{4}-[0-9]{2}-[0-9]{2}(_[0-9]{4,6})?[_-]?//g')
        base=$(echo "$base" | sed -E 's/[_-]?[0-9]{8}-[0-9]{6}[_-]?//g')
        base=$(echo "$base" | sed -E 's/[_-]?[0-9]{14}[_-]?//g')
        base=$(echo "$base" | sed -E 's/[_-]?[0-9]{8}[_-]?//g')
        if [[ ! "$base" =~ [_-] ]]; then
            if [[ "$base" =~ ^[A-Z0-9]+$ ]]; then
                echo "$(echo "$base" | awk '{print toupper(substr($0,1,1)) tolower(substr($0,2))}')"
            else
                echo "$(echo "${base:0:1}" | tr '[:lower:]' '[:upper:]')${base:1}"
            fi
            return
        fi
        echo "$base" | sed -e 's/[_-]/ /g' | awk '{for(i=1;i<=NF;i++){$i=toupper(substr($i,1,1)) tolower(substr($i,2))}}1' | sed 's/ //g'
    }

    # Parse duration string to seconds
    parseDurationToSeconds() {
        local duration="$1"
        local num="${duration%[dwmy]}"
        local unit="${duration#$num}"
        [ -z "$unit" ] && unit="d"
        case "$unit" in
            d) echo $((num * 86400)) ;;
            w) echo $((num * 7 * 86400)) ;;
            m) echo $((num * 30 * 86400)) ;;
            y) echo $((num * 365 * 86400)) ;;
            *) echo "Invalid duration unit: $unit" >&2; return 1 ;;
        esac
    }

    # Collect files to prune
    collectPruneOps() {
        local repoRoot="$1" duration="$2"
        local cutoffTime
        cutoffTime=$(($(date +%s) - $(parseDurationToSeconds "$duration")))
        local files
        files=$(cd "$repoRoot" && find aidocs -type f -name "*.md" 2>/dev/null | sed 's|^./||' | grep -v "^aidocs/README.md$")
        local pruneOps=()
        for f in $files; do
            local mtime
            mtime=$(stat -f "%m" "$repoRoot/$f" 2>/dev/null || echo 0)
            [ "$mtime" -lt "$cutoffTime" ] && pruneOps+=("$f")
        done
        echo "${pruneOps[@]}"
    }

    # Collect files to normalize in specified directories
    collectNormalizeOps() {
        local repoRoot="$1"
        local dirs=("${@:2}")
        local normalizeOps=()
        for dir in "${dirs[@]}"; do
            [ ! -d "$repoRoot/$dir" ] && continue
            local files
            files=$(cd "$repoRoot" && find "$dir" -type f 2>/dev/null | sed 's|^./||' || true)
            for filepath in $files; do
                [ -z "$filepath" ] && continue
                local dirname filename base extension
                dirname=$(dirname "$filepath")
                filename=$(basename "$filepath")
                base="${filename%.*}"
                extension="${filename##*.}"
                [ "$extension" = "$filename" ] && extension=""
                # Extract timestamp
                local ts date time
                ts=$(extractTimestamp "$base")
                date="${ts%%|*}"; time="${ts##*|}"
                [ -z "$date" ] && date=$(date -r $(stat -f "%m" "$repoRoot/$filepath" 2>/dev/null || echo 0) '+%Y-%m-%d' 2>/dev/null || echo "unknown")
                [ -z "$time" ] && time=$(date -r $(stat -f "%m" "$repoRoot/$filepath" 2>/dev/null || echo 0) '+%H%M' 2>/dev/null || echo "0000")
                local camelCaseName
                camelCaseName=$(toCamelCase "$base")
                local newFilename newPath
                if [ -n "$extension" ]; then
                    newFilename="${date}_${time}_${camelCaseName}.${extension}"
                else
                    newFilename="${date}_${time}_${camelCaseName}"
                fi
                newPath="${dirname}/${newFilename}"
                # Compliance: filename matches normalized pattern (yyyy-mm-dd_hhmm_CamelCase.ext)
                local compliantPattern='^[0-9]{4}-[0-9]{2}-[0-9]{2}_[0-9]{4}_[A-Z][A-Za-z0-9]*(\.[^.]+)?$'
                if [[ ! "$filename" =~ $compliantPattern ]] && [ "$filepath" != "$newPath" ]; then
                    normalizeOps+=("$filepath|$newPath")
                fi
            done
        done
        echo "${normalizeOps[@]}"
    }

    # Main logic
    local markdownFiles
    markdownFiles=$(findUntrackedMarkdown "$repoRoot" "$depth" "$inGitRepo")
    markdownFiles=$(normalizePaths "$markdownFiles")
    local untrackedOps=()
    while IFS= read -r file; do
        [ -z "$file" ] && continue
        local base
        base=$(basename "$file")
        local ts
        ts=$(extractTimestamp "$base")
        local date="${ts%%|*}" time="${ts##*|}"
        if [ -z "$date" ]; then
            local btime mtime
            btime=$(stat -f "%B" "$file" 2>/dev/null || echo 0)
            mtime=$(stat -f "%m" "$file" 2>/dev/null || echo 0)
            date=$(date -r "${btime:-$mtime}" '+%Y-%m-%d' 2>/dev/null || echo "unknown")
            time=$(date -r "${btime:-$mtime}" '+%H%M' 2>/dev/null || echo "0000")
        fi
        local camel
        camel=$(toCamelCase "$base")
        local dest="aidocs/$date/${time}_${camel}.md"
        untrackedOps+=("$file|$dest")
    done <<< "$markdownFiles"

    local normalizeOps=()
    if [ "$normalizeExplicit" -eq 1 ] && [ ${#normalizeDirs[@]} -gt 0 ]; then
        normalizeOps=($(collectNormalizeOps "$repoRoot" "${normalizeDirs[@]}"))
    fi

    local pruneOps=()
    [ -n "$pruneDuration" ] && pruneOps=($(collectPruneOps "$repoRoot" "$pruneDuration"))

    local totalOps=$(( ${#untrackedOps[@]} + ${#normalizeOps[@]} + ${#pruneOps[@]} ))
    [ "$totalOps" -eq 0 ] && echo "Executed 0 of 0 proposed operations" >&2 && exit 0

    local maxLen=0
    for op in "${untrackedOps[@]}" "${normalizeOps[@]}"; do
        local src="${op%%|*}"
        [ ${#src} -gt $maxLen ] && maxLen=${#src}
    done
    for file in "${pruneOps[@]}"; do
        [ ${#file} -gt $maxLen ] && maxLen=${#file}
    done

    # Display normalization operations first if present
    if [ ${#normalizeOps[@]} -gt 0 ]; then
        for op in "${normalizeOps[@]}"; do
            local src="${op%%|*}" dst="${op##*|}"
            printf "  %-${maxLen}s  →  %s\n" "$src" "$dst"
        done
    fi
    for op in "${untrackedOps[@]}"; do
        local src="${op%%|*}" dst="${op##*|}"
        printf "  %-${maxLen}s  →  %s\n" "$src" "$dst"
    done
    for file in "${pruneOps[@]}"; do
        printf "  %-${maxLen}s  →  [DELETE]\n" "$file"
    done

    [ "$dryRun" -eq 1 ] && echo "Executed 0 of $totalOps proposed operations" >&2 && exit 0

    if [ "$autoConfirm" -eq 0 ]; then
        read -p "Proceed with these operations? [y/N] " -n 1 -r
        echo
        [[ ! $REPLY =~ ^[Yy]$ ]] && echo "Cancelled." >&2 && echo "Executed 0 of $totalOps proposed operations" >&2 && exit 0
    fi

    local executedOps=0
    for op in "${normalizeOps[@]}"; do
        local src="${op%%|*}" dst="${op##*|}"
        local destDir
        destDir=$(dirname "$dst")
        mkdir -p "$destDir"
        if [ -f "$dst" ]; then
            printf "  ⚠ %-${maxLen}s  (destination exists)\n" "$src"
            continue
        fi
        if mv "$src" "$dst"; then
            executedOps=$((executedOps+1))
            printf "  ✓ %-${maxLen}s  →  %s\n" "$src" "$dst"
        else
            printf "  ⚠ %-${maxLen}s  (failed to move)\n" "$src" >&2
        fi
    done
    for op in "${untrackedOps[@]}"; do
        local src="${op%%|*}" dst="${op##*|}"
        local destDir
        destDir=$(dirname "$dst")
        mkdir -p "$destDir"
        if [ -f "$dst" ]; then
            printf "  ⚠ %-${maxLen}s  (destination exists)\n" "$src"
            continue
        fi
        if mv "$src" "$dst"; then
            executedOps=$((executedOps+1))
            printf "  ✓ %-${maxLen}s  →  %s\n" "$src" "$dst"
        else
            printf "  ⚠ %-${maxLen}s  (failed to move)\n" "$src" >&2
        fi
    done
    for file in "${pruneOps[@]}"; do
        if [ -f "$file" ] && rm "$file"; then
            executedOps=$((executedOps+1))
            printf "  ✓ %-${maxLen}s  →  [DELETED]\n" "$file"
        else
            printf "  ⚠ %-${maxLen}s  (failed to delete)\n" "$file" >&2
        fi
    done
    echo "Executed $executedOps of $totalOps proposed operations" >&2
}

main "$@"
